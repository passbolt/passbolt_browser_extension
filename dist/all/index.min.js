(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * Main include file.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

/* ===================================================================================
 *  Events
 *
 *  Events help the addon code interact with content code via content/workers
 *  given by the pagemod. Read more about it here:
 *  https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/content_worker
 *
 *  These section contain events includes that is reusable by the listeners
 *  themselves. This allows to factorize some code common to many listeners.
 *  For example multiple listeners will be will interested in sending/receiving
 *  encryption and decryption events.
 * ==================================================================================
 */
var events = {};
events.app = require('./event/appEvents');
events.auth = require('./event/authEvents');
events.clipboard = require('./event/clipboardEvents');
events.config = require('./event/configEvents');
events.debug = require('./event/debugEvents');
events.editPassword = require('./event/editPasswordEvents');
events.file = require('./event/fileEvents');
events.group = require('./event/groupEvents');
events.groupAutocomplete = require('./event/groupAutocompleteEvents');
events.keyring = require('./event/keyringEvents');
events.masterPasswordIframe = require('./event/masterPasswordIframeEvents');
events.masterPassword = require('./event/masterPasswordEvents');
events.passboltPage = require('./event/passboltPageEvents');
events.secret = require('./event/secretEvents');
events.setup = require('./event/setupEvents');
events.setupbootstrap = require('./event/setupBootstrapEvents');
events.shareAutocomplete = require('./event/shareAutocompleteEvents');
events.share = require('./event/shareEvents');
events.template = require('./event/templateEvents');
events.user = require('./event/userEvents');

exports.events = events;

/* ==================================================================================
 *  Page mods
 *  Run scripts in the context of web pages whose URL matches a given pattern.
 *  see. https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/page-mod
 * ==================================================================================
 */
/*
 * Each pagemod triggers a worker that can be used to communicate between the add-on and content code.
 * We need to store these workers in a global objects because they need to be able to
 * communicate with each other
 */
var workers = {};
exports.workers = workers;

/*
 * Content code callbacks are UUIDs generated by the content code and mapped with an anonymous
 * function on the content code side. This UUID is given to the add-on code when the content code
 * is triggering a request for a process managed at the addon level such as encrypt or decrypt.
 * We cannot give directly the function reference since the add-on and content code can only
 * communicate via text.
 */
var callbacks = {};
exports.callbacks = callbacks;

/*
 * We use this variables to store the references to the pagemods
 * It is usefull for example to re-initialize pagemods after a configuration changes
 * for example when you change the list of domains that you are running passbolt on
 */
var pageMods = {};

/*
 * This pagemod allow inserting classes to help any page
 * to know about the status of the extension, in a modernizr fashion
 * It also helps the plugin to recognise if a page behave like a passbolt app
 */
pageMods.Bootstrap = require('./pagemod/bootstrapPagemod').Bootstrap;

/*
 * This pagemod drives the login / authentication
 */
pageMods.PassboltAuth = require('./pagemod/passboltAuthPagemod').PassboltAuth;

/*
 * This pagemod drives the login passphrase capture
 */
pageMods.PassboltAuthForm = require('./pagemod/passboltAuthFormPagemod').PassboltAuthForm;

/*
 * This pagemod help bootstrap the first step of the setup process from a passbolt server app page
 * The pattern for this url, driving the setup bootstrap, is defined in config.json
 */
pageMods.SetupBootstrap = require('./pagemod/setupBootstrapPagemod').SetupBootstrap;

/*
 * This page mod drives the reset of setup process
 * The reset of the setup process is driven on the add-on side, see in ../data/ setup.html and js/setup.js
 */
pageMods.Setup = require('./pagemod/setupPagemod').Setup;

/*
 * This pagemod drives the main addon app
 * It is inserted in all the pages of a domain that is trusted.
 * Such trust is defined during the first step of the setup process (or in config-debug)
 */
pageMods.PassboltApp = require('./pagemod/passboltAppPagemod').PassboltApp;

/*
 * This pagemod drives the dialog/iframe where the user enters the secret key password,
 * also called passphrase. It is used when encrypting, decrypting, signing, etc.
 */
pageMods.MasterPasswordDialog = require('./pagemod/masterPasswordDialogPagemod').MasterPasswordDialog;

/*
 * This pagemod drives the progress bar iframe
 * It is used when the add-on is encrypting something
 */
pageMods.ProgressDialog = require('./pagemod/progressDialogPagemod').ProgressDialog;

/*
 * This pagemod drives the iframe used when the user enter a password to be stored by passbolt
 * It is used when creating/editing a new password
 */
pageMods.SecretEditDialog = require('./pagemod/secretEditDialogPagemod').SecretEditDialog;

/*
 * This pagemod drives the iframe used when the user share a password
 * It is used when sharing a new password
 */
pageMods.ShareDialog = require('./pagemod/shareDialogPagemod').ShareDialog;

/*
 * This pagemod drives the iframe used when the user share a password
 * and he is looking for new users to grant
 */
pageMods.ShareAutocompleteDialog = require('./pagemod/shareAutocompleteDialogPagemod').ShareAutocompleteDialog;

/*
 * This pagemod drives the iframe used when the user creates / edit a group.
 * It is used when selecting the users who are part of the group.
 */
pageMods.GroupEditDialog = require('./pagemod/groupEditDialogPagemod').GroupEditDialog;

/*
 * This pagemod drives the iframe used when the user creates / edit a group.
 * It shows the autocomplete list including the users that can be added to the group.
 */
pageMods.GroupEditAutocompleteDialog = require('./pagemod/groupEditAutocompleteDialogPagemod').GroupEditAutocompleteDialog;

/*
 * This page mod drives a convenience config page for debug
 * This allows to not have to go through the setup process steps
 * and perform changes useful for testing that would otherwise break things
 * Like for example changing the public key only on the client but not the server
 */
pageMods.Debug = require('./pagemod/debugPagemod').Debug;

exports.pageMods = pageMods;

},{"./event/appEvents":8,"./event/authEvents":9,"./event/clipboardEvents":10,"./event/configEvents":11,"./event/debugEvents":12,"./event/editPasswordEvents":13,"./event/fileEvents":14,"./event/groupAutocompleteEvents":15,"./event/groupEvents":16,"./event/keyringEvents":17,"./event/masterPasswordEvents":18,"./event/masterPasswordIframeEvents":19,"./event/passboltPageEvents":20,"./event/secretEvents":21,"./event/setupBootstrapEvents":22,"./event/setupEvents":23,"./event/shareAutocompleteEvents":24,"./event/shareEvents":25,"./event/templateEvents":26,"./event/userEvents":27,"./pagemod/bootstrapPagemod":46,"./pagemod/debugPagemod":47,"./pagemod/groupEditAutocompleteDialogPagemod":48,"./pagemod/groupEditDialogPagemod":49,"./pagemod/masterPasswordDialogPagemod":50,"./pagemod/passboltAppPagemod":51,"./pagemod/passboltAuthFormPagemod":52,"./pagemod/passboltAuthPagemod":53,"./pagemod/progressDialogPagemod":54,"./pagemod/secretEditDialogPagemod":55,"./pagemod/setupBootstrapPagemod":56,"./pagemod/setupPagemod":57,"./pagemod/shareAutocompleteDialogPagemod":58,"./pagemod/shareDialogPagemod":59}],2:[function(require,module,exports){
module.exports={
  "extensionId": "passbolt@passbolt.com",
  "extensionBasePath": "resource://passbolt-at-passbolt-dot-com",
  "baseUrl": "https://demo.passbolt.com",
  "debug": true
}

},{}],3:[function(require,module,exports){
/**
 * Browser Settings Controller.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
/**
 * Get the value of given browser setting
 *
 * @param {string} key
 * @return {string} value
 */
var get = function (key) {
  switch (key) {
    case 'browser.download.dir':
    case 'browser.download.lastDir':
    //break;
    default:
      console.error('Chrome browserSettingsController::get for key ' + key + ' not implemented');
      return undefined;
      break;
  }
};
exports.get = get;

/**
 * Set the value of given browser setting
 *
 * @param {string} key
 * @param {string} value
 */
var set = function (key, value) {
  console.error('Chrome browserSettingsController::set not implemented');
};
exports.set = set;

/**
 * Get the extension version.
 *
 * @return {string}
 */
var getExtensionVersion = function () {
  return chrome.runtime.getManifest().version;
};
exports.getExtensionVersion = getExtensionVersion;

},{}],4:[function(require,module,exports){
/**
 * Clipboard controller.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
/**
 * Copy a text to the clipboard.
 *
 * @param {string} The text to copy.
 */
var copy = function(text) {
  var copyFrom = document.createElement('textarea');
  copyFrom.textContent = text;
  var body = document.getElementsByTagName('body')[0];
  body.appendChild(copyFrom);
  copyFrom.select();
  document.execCommand('copy');
  body.removeChild(copyFrom);
};
exports.copy = copy;

},{}],5:[function(require,module,exports){
/**
 * File controller.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var self = require('../sdk/self');
var __ = require('../sdk/l10n').get;
const defer = require('../sdk/core/promise').defer;

/**
 * Save file on disk using download
 *
 * @param filename
 * @param content
 * @return {promise}
 */
function saveFile(filename, content) {
  var deferred = defer();

  var a = document.createElement('a');
  var blob = new Blob([ content ], {type : "text/plain;charset=UTF-8"});
  a.href = window.URL.createObjectURL(blob);
  a.download = filename;
  a.style.display = 'none';
  document.body.appendChild(a);
  a.click();
  delete a;

  deferred.resolve();
  return deferred.promise;
}
exports.saveFile = saveFile;

/**
 * Open file content using upload
 *
 * @return {promise} content of a file selected by the user
 */
function openFile() {
  var deferred = defer();
  chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
    chrome.tabs.sendMessage(tabs[0].id, {custom: "passbolt.file.open"}, function(response) {
      if(typeof response !== 'undefined' && typeof response.data !== 'undefined') {
        deferred.resolve(response.data);
      } else {
        deferred.reject(new Error(__('Something went wrong when trying to open the file. Please retry.')));
      }
    });
  });
  return deferred.promise;
}
exports.openFile = openFile;

/**
 * Get the prefered download directory path
 *
 * @return {promise}
 */
function getPreferredDownloadsDirectory() {
  var deferred = defer();
  deferred.reject(new Error('chrome/lib/fileController::getPreferredDownloadsDirectory missing'));
  return deferred.promise;
}
exports.getPreferredDownloadsDirectory = getPreferredDownloadsDirectory;

/**
 * Load file content.
 * @param path {string} Path of the file to load
 * @return {promise}
 */
function loadFile (path) {
  var deferred = defer();
	var url = chrome.runtime.getURL(path);
  fetch(url)
    .then(
      function (response) {
         deferred.resolve(response.text());
      },
      function (error) {
        deferred.reject(error);
      }
    );
  return deferred.promise;
}
exports.loadFile = loadFile;

},{"../sdk/core/promise":60,"../sdk/l10n":61,"../sdk/self":65}],6:[function(require,module,exports){
/**
 * Master password controller.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

/**
 * This utility function allows to manage several password attempts
 * Currently it is used only when decrypting content but this system
 * can be reusable for other features in the future like authentication
 */
const { defer } = require('../sdk/core/promise');
var User = require('../model/user').User;
var Worker = require('../model/worker');
var TabStorage = require('../model/tabStorage').TabStorage;

/**
 * Get the user master password. If a remembered master password exists
 * return it, otherwise prompt the user.
 *
 * @param worker The worker asking for the master password.
 * @returns {d.promise|*|promise} The promise to resolve/reject when the master password is retrieved.
 */
var get = function (worker) {
  var deferred = defer(),
    user = new User();

  // Try to retrieve a remembered passphrase.
  user.getStoredMasterPassword().then(
    // If a passphrase is remembered, use it.
    function (masterPassword) {
      deferred.resolve(masterPassword);
    },
    // If no passphrase is remembered, prompt the user.
    function () {
      _promptUser(worker, deferred);
    }
  );

  return deferred.promise;
};
exports.get = get;

/**
 * Prompt the user to enter their master password.
 *
 * @param worker The worker asking for the master password.
 * @param deferred The promise to resolve/reject when the master password is retrieved.
 * @private
 */
var _promptUser = function (worker, deferred) {
  var masterPasswordRequest = {
      attempts: 0,
      deferred: deferred
    };

  // Store the masterPassword request in the tab storage.
  TabStorage.set(worker.tab.id, 'masterPasswordRequest', masterPasswordRequest);

  // Init the master password dialog.
  Worker.get('App', worker.tab.id).port.emit('passbolt.master-password.open-dialog');
};

},{"../model/tabStorage":43,"../model/user":44,"../model/worker":45,"../sdk/core/promise":60}],7:[function(require,module,exports){
/**
 * Tab controller.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
const defer = require('../sdk/core/promise').defer;

/**
 * Open an url in a new tab.
 * @param url {string} The url to open
 */
var open = function (url) {
  chrome.tabs.create({url: url});
};
exports.open = open;

/**
 * Get the active tab url.
 * @return {string}
 */
var getActiveTabUrl = function () {
  var deferred = defer();
  chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
    return deferred.resolve(tabs[0].url);
  });
  return deferred.promise;
};
exports.getActiveTabUrl = getActiveTabUrl;

/**
 * Set the active tab url.
 * @param url {string} The url to go to
 */
var setActiveTabUrl = function (url) {
  chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
    var tab = tabs[0];

    // In case the url given was generated using self.data.url
    // remove the chrome-extension://<plugin id>/ part of the url
    // since it's added again by chrome.tabs.update
    var replaceStr = 'chrome-extension://' + chrome.runtime.id + '/';
    url = url.replace(replaceStr, '');

    chrome.tabs.update(tab.id, {url: url});
  });
};
exports.setActiveTabUrl = setActiveTabUrl;

},{"../sdk/core/promise":60}],8:[function(require,module,exports){
/**
 * App events.
 *
 * Used to handle the events related to main application page.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var masterPasswordController = require('../controller/masterPasswordController');
var clipboardController = require('../controller/clipboardController');
var app = require('../app');
var __ = require('../sdk/l10n').get;
var Worker = require('../model/worker');
const { Promise, defer } = require('../sdk/core/promise');
var { setInterval, clearInterval } = require('../sdk/timers');

var Keyring = require('../model/keyring').Keyring;
var Crypto = require('../model/crypto').Crypto;
var TabStorage = require('../model/tabStorage').TabStorage;
var Secret = require('../model/secret').Secret;
var secret = new Secret();
var Resource = require('../model/resource').Resource;

var listen = function (worker) {

  /*
   * Broadcast the window resize event to all workers.
   *
   * @listens passbolt.app.window-resized
   * @param cssClasses {array} When the window is resized the application
   *  updates the css classes applied to its html tag, these classes are given
   *  as parameter.
   */
  worker.port.on('passbolt.app.window-resized', function (cssClasses) {
    var workersIds = Worker.getAllKeys(worker.tab.id);
    for (var i in workersIds) {
      Worker.get(workersIds[i], worker.tab.id).port.emit('passbolt.app.window-resized', cssClasses);
    }
  });

  /*
   * Give the focus to the secret-edit iframe.
   *
   * @listens passbolt.secret-edit.focus
   */
  worker.port.on('passbolt.secret-edit.focus', function () {
    Worker.get('Secret', worker.tab.id).port.emit('passbolt.secret-edit.focus');
  });

  /* Validate the edited secret.
   *
   * @listens passbolt.secret-edit.validate
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.secret-edit.validate', function (requestId) {
    var editedPassword = TabStorage.get(worker.tab.id, 'editedPassword');

    try {
      // If the secret is decrypted validate it, otherwise it is
      // considered as valid.
      if (editedPassword.secret != null) {
        secret.validate({data: editedPassword.secret});
      }
      Worker.get('Secret', worker.tab.id).port.emit('passbolt.secret-edit.validate-success');
      worker.port.emit(requestId, 'SUCCESS');
    } catch (e) {
      Worker.get('Secret', worker.tab.id).port.emit('passbolt.secret-edit.validate-error', e.message, e.validationErrors);
      worker.port.emit(requestId, 'ERROR', e.message, e.validationErrors);
    }
  });

  /*
   * Encrypt the currently edited secret for all given users. Send the armored
   * secrets in the response to the requester. If the secret hasn't been
   * decrypted send an empty array.
   *
   * @listens passbolt.secret-edit.encrypt
   * @param requestId {uuid} The request identifier
   * @param usersIds {array} The users to encrypt the edited secret for
   */
  worker.port.on('passbolt.secret-edit.encrypt', function (requestId, usersIds) {
    var editedPassword = TabStorage.get(worker.tab.id, 'editedPassword'),
      keyring = new Keyring(),
      crypto = new Crypto(),
      armoreds = {};

    // If the currently edited secret hasn't been decrypted, leave.
    if (editedPassword.secret == null) {
      worker.port.emit(requestId, 'SUCCESS', armoreds);
      return;
    }

    // Open the progress dialog.
    worker.port.emit('passbolt.progress.open-dialog', 'Encrypting ...', usersIds.length);

    // Sync the keyring with the server.
    keyring.sync()

      // Once the keyring is synced, encrypt the secret for each user.
      .then(function () {
        // Store the encryption promise for each user in this array.
        // Encryptions will be treated in parallel to optimize the treatment.
        var promises = [],
          progress = 0,
          progressWorker = null;

        usersIds.forEach(function (userId) {
          var p = crypto.encrypt(editedPassword.secret, userId);
          promises.push(p);

          // Update the progress dialog.
          p.then(function () {
            progress++;
            progressWorker = Worker.get('Progress', worker.tab.id);
            if (progressWorker != null) {
              progressWorker.port.emit('passbolt.progress.update', 'Encrypted for ' + userId, progress);
            }
          });
        });

        return Promise.all(promises);
      })

      // Once the secret is encrypted for all users notify the application and
      // close the progress dialog.
      .then(function (data) {
        for (var i in data) {
          armoreds[usersIds[i]] = data[i];
        }
        worker.port.emit(requestId, 'SUCCESS', armoreds);
        worker.port.emit('passbolt.progress.close-dialog');
      });
  });

  /*
   * Initialize the password sharing process.
   *
   * @listens passbolt.app.share-password-init
   * @param requestId {uuid} The request identifier
   * @param sharedPassword {array} The password to share
   */
  worker.port.on('passbolt.app.share-password-init', function (requestId, sharedPassword) {
    // Store some variables in the tab storage in order to make it accessible by other workers.
    TabStorage.set(worker.tab.id, 'sharedPassword', sharedPassword);
    TabStorage.set(worker.tab.id, 'shareWith', []);
    worker.port.emit(requestId, 'SUCCESS');
  });

  /*
   * Encrypt the shared password for all the new users it has been shared with.
   *
   * @listens passbolt.share.encrypt
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.share.encrypt', function (requestId) {
    var sharedPassword = TabStorage.get(worker.tab.id, 'sharedPassword'),
      aros = TabStorage.get(worker.tab.id, 'shareWith'),
      addedUsers = [],
      keyring = new Keyring(),
      crypto = new Crypto();

    if (!aros.length) {
      worker.port.emit(requestId, 'SUCCESS', {});
      return;
    }

    // Master password required to decrypt a secret before sharing it.
    masterPasswordController.get(worker)

      // Once the master password retrieved, decrypt the secret.
      .then(function (masterPassword) {
        return crypto.decrypt(sharedPassword.armored, masterPassword)
      })

      // Once the password decrypted :
      // - notify the user about the process progression.
      // - Sync the keyring.
      .then(function (secret) {
        sharedPassword.secret = secret;
        // Notify the user regarding the encryption process starting.
        worker.port.emit('passbolt.progress.open-dialog', 'Encrypting ...');
        // Sync the keyring.
        return keyring.sync();
      })

      // Retrieve the new users the secret will be encrypted for.
      .then(function () {
        var permissions = [];
        aros.forEach(function (aro) {
          var permission = {
            aco: 'Resource',
            aro: aro.User ? 'User' : 'Group',
            aro_foreign_key: aro.User ? aro.User.id : aro.Group.id,
            type: 1
          };
          permissions.push({Permission: permission});
        });
        return Resource.simulateShare(sharedPassword.resourceId, permissions);
      })

      // Once the keyring is synced, encrypt the secret for each user.
      .then(function (response) {
        // Encryptions will be done in parallel.
        var promises = [],
          progress = 0;

        // User to encyrpt the secret for.
        addedUsers = response.changes.added;

        // Encrypt the secret for each new user.
        for (var i in addedUsers) {
          var user = addedUsers[i].User,
            p = crypto.encrypt(sharedPassword.secret, user.id);

          promises.push(p);

          // Update the progress dialog.
          p.then(function () {
            var progressWorker = Worker.get('Progress', worker.tab.id);
            if (progressWorker) {
              progressWorker.port.emit('passbolt.progress.update', 'Encrypted for ' + userId, progress++, addedUsers.length);
            }
          });
        }

        return Promise.all(promises);
      })

      // Once the secret is encrypted for all users notify the application and
      // close the progress dialog.
      .then(function (data) {
        var armoreds = {};
        for (var i in data) {
          armoreds[addedUsers[i].User.id] = data[i];
        }
        worker.port.emit(requestId, 'SUCCESS', armoreds);
        worker.port.emit('passbolt.progress.close-dialog');
      })

      // In case of error, notify the request caller.
      .then(null, function (error) {
        worker.port.emit(requestId, 'ERROR', error);
      });

  });

  /*
   * A permission has been temporary deleted.
   * Remove the aro from the list of aros the password would be shared with.
   *
   * @listens passbolt.share.remove-permission
   * @param removedAroId {string} The aro id to remove.
   */
  worker.port.on('passbolt.share.remove-permission', function (removedAroId) {
    var aros = TabStorage.get(worker.tab.id, 'shareWith') || [];

    for(var i in aros) {
      var aroId = aros[i].User ? aros[i].User.id : aros[i].Group.id;
      if(aroId == removedAroId) {
        aros.splice(i, 1);
      }
    }

    TabStorage.set(worker.tab.id, 'shareWith', aros);
  });

  /*
   * Decrypt a given armored string and store it in the clipboard.
   *
   * @listens passbolt.app.decrypt-copy
   * @param requestId {uuid} The request identifier
   * @param armored {string} The armored secret
   */
  worker.port.on('passbolt.app.decrypt-copy', function (requestId, armored) {
    var crypto = new Crypto();

    // Master password required to decrypt a secret.
    masterPasswordController.get(worker)

      // Once the master password retrieved, decrypt the secret.
      .then(function (masterPassword) {
        return crypto.decrypt(armored, masterPassword)
      })

      // Once the secret is decrypted, answer to the requester.
      .then(function (decrypted) {
        clipboardController.copy(decrypted);
        worker.port.emit(requestId, 'SUCCESS');
      })

      // Catch any error.
      .then(null, function (error) {
        worker.port.emit(requestId, 'ERROR', error);
      });
  });
};



exports.listen = listen;

},{"../app":1,"../controller/clipboardController":4,"../controller/masterPasswordController":6,"../model/crypto":31,"../model/keyring":37,"../model/resource":39,"../model/secret":40,"../model/tabStorage":43,"../model/worker":45,"../sdk/core/promise":60,"../sdk/l10n":61,"../sdk/timers":67}],9:[function(require,module,exports){
/**
 * Auth events.
 *
 * Used to handle the events related to authentication.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var Auth = require('../model/auth').Auth;
var auth = new Auth();

var __ = require('../sdk/l10n').get;
var Worker = require('../model/worker');

var listen = function (worker) {

  /*
   * Verify the server identity.
   *
   * @listens passbolt.auth.verify
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.auth.verify', function (requestId) {
    auth.verify().then(
      function success(msg) {
        worker.port.emit(requestId, 'SUCCESS', msg);
      },
      function error(error) {
        worker.port.emit(requestId, 'ERROR', error.message);
      }
    );
  });

  /*
   * Get the password server key for a given domain.
   *
   * @listens passbolt.auth.getServerKey
   * @param requestId {uuid} The request identifier
   * @param domain {string} The server's domain
   */
  worker.port.on('passbolt.auth.getServerKey', function (requestId, domain) {
    auth.getServerKey(domain).then(
      function success(msg) {
        worker.port.emit(requestId, 'SUCCESS', msg);
      },
      function error(error) {
        worker.port.emit(requestId, 'ERROR', error.message);
      }
    );
  });

  /*
   * Attempt to login the current user.
   *
   * @listens passbolt.auth.login
   * @param requestId {uuid} The request identifier
   * @param masterpassword {string} The master password to use for the authentication attempt.
   */
  worker.port.on('passbolt.auth.login', function (requestId, masterpassword) {
    var tabId = worker.tab.id;
    Worker.get('Auth', worker.tab.id).port.emit('passbolt.auth.login-processing', __('Logging in'));
    auth.login(masterpassword).then(
      function success(referrer) {
        // init the app pagemod
        var app = require('../app');
        app.pageMods.PassboltApp.init();

        // redirect
        var msg = __('You are now logged in!');
        Worker.get('Auth', tabId).port.emit('passbolt.auth.login-success', msg, referrer);
      },
      function error(error) {
        Worker.get('Auth', tabId).port.emit('passbolt.auth.login-failed', error.message);
      }
    );
  });

  /*
   * Ask the login page to add a css class to an HTML Element.
   *
   * @listens passbolt.auth.add-class
   * @param selector {string} The HTML Element selector
   * @param cssClass {string} The class(es) to add to the html element
   */
  worker.port.on('passbolt.auth.add-class', function (selector, cssClass) {
    Worker.get('Auth', worker.tab.id).port.emit('passbolt.auth.add-class', selector, cssClass);
  });

  /*
   * Ask the login page to remove a css class from an HTML Element.
   *
   * @listens passbolt.auth.remove-class
   * @param selector {string} The HTML Element selector
   * @param cssClass {string} The class(es) to remove from the html element
   */
  worker.port.on('passbolt.auth.remove-class', function (selector, cssClass) {
    Worker.get('Auth', worker.tab.id).port.emit('passbolt.auth.remove-class', selector, cssClass);
  });

};

exports.listen = listen;

},{"../app":1,"../model/auth":29,"../model/worker":45,"../sdk/l10n":61}],10:[function(require,module,exports){
/**
 * Clipboard events
 * @TODO flush clipboard event (on logout for example)
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var clipboardController = require('../controller/clipboardController');

var listen = function (worker) {

  /*
   * Copy to clipoard.
   *
   * @listens passbolt.clipboard.copy
   * @param txt {string} The string to copy to clipboard
   */
  worker.port.on('passbolt.clipboard.copy', function (txt) {
    clipboardController.copy(txt);
  });

};
exports.listen = listen;
},{"../controller/clipboardController":4}],11:[function(require,module,exports){
/**
 * Config Listeners
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var BrowserSettings = require('../controller/browserSettingsController');
var tabsController = require('../controller/tabsController');
var Config = require('../model/config');
var User = require('../model/user').User;

var listen = function (worker) {

  /*
   * Read configuration variable.
   *
   * @listens passbolt.config.read
   * @param requestId {uuid} The request identifier
   * @param name {string} Variable name to obtain
   */
  worker.port.on('passbolt.config.read', function (requestId, name) {
    worker.port.emit(requestId, 'SUCCESS', Config.read(name));
  });

  /*
   * Read multiple configuration variables.
   *
   * @listens passbolt.config.readAll
   * @param requestId {uuid} The request identifier
   * @param names {array} Variable names to obtain
   */
  worker.port.on('passbolt.config.readAll', function (requestId, names) {
    var conf = {};
    for (var i in names) {
      conf[names[i]] = Config.read(names[i]);
    }
    worker.port.emit(requestId, 'SUCCESS', conf);
  });

  /*
   * Check if the plugin is well configured
   *
   * @listens passbolt.addon.isConfigured
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.addon.isConfigured', function (requestId) {
    var user = new User();
    worker.port.emit(requestId, 'SUCCESS', user.isValid());
  });

  /*
   * Check if the current domain matches the trusted domain defined in configuration.
   * Only works if the plugin is configured.
   *
   * @listens passbolt.addon.checkDomain
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.addon.checkDomain', function (requestId) {
    var trustedDomain = Config.read('user.settings.trustedDomain');
    if(typeof trustedDomain === 'undefined' || trustedDomain == '') {
      worker.port.emit(requestId, 'SUCCESS', false);
    }

    var domainOk = worker.tab.url.startsWith(trustedDomain);
    worker.port.emit(requestId, 'SUCCESS', domainOk);
  });

  /*
   * Get trusted domain.
   *
   * @listens passbolt.addon.getDomain
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.addon.getDomain', function (requestId) {
    var trustedDomain = Config.read('user.settings.trustedDomain');
    worker.port.emit(requestId, 'SUCCESS', trustedDomain);
  });

  /*
   * Set a configuration variable.
   *
   * @listens passbolt.config.write
   * @param requestId {uuid} The request identifier
   * @param name {string} Variable name to store
   * @param value {mixed} Variable value
   */
  worker.port.on('passbolt.config.write', function (requestId, name, value) {
    var write = Config.write(name, value);
    if (write) {
      worker.port.emit(requestId, 'SUCCESS');
    }
  });

  /*
   * Get plugin version.
   *
   * @listens passbolt.addon.getDomain
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.addon.getVersion', function (requestId) {
    worker.port.emit(requestId, 'SUCCESS', BrowserSettings.getExtensionVersion());
  });
};
exports.listen = listen;
},{"../controller/browserSettingsController":3,"../controller/tabsController":7,"../model/config":30,"../model/user":44}],12:[function(require,module,exports){
/**
 * Debug Listeners
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var Config = require('../model/config');
var BrowserSettings = require('../controller/browserSettingsController');

var listen = function (worker) {

  /*
   * Retrieve all the plugin configuration variables.
   *
   * @listens passbolt.debug.config.readAll
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.debug.config.readAll', function (requestId) {
    worker.port.emit(requestId, 'SUCCESS', Config.readAll());
  });

  /*
   * Read preference variable.
   *
   * @listens passbolt.debug.browser.readPreference
   * @param requestId {uuid} The request identifier
   * @param preferenceKey {string} Preference name to obtain
   */
  worker.port.on('passbolt.debug.browser.readPreference', function (requestId, preferenceKey) {
    worker.port.emit(requestId, 'SUCCESS', BrowserSettings.get(preferenceKey));
  });

  /*
   * Flush plugin configuration.
   *
   * @listens passbolt.debug.config.flush
   */
  worker.port.on('passbolt.debug.config.flush', function () {
    Config.flush();
  });

  /*
   * Initialize the application pagemod.
   *
   * @listens passbolt.debug.appPagemod.init
   */
  worker.port.on('passbolt.debug.appPagemod.init', function () {
    var app = require('../app');
    app.pageMods.PassboltApp.init();
  });
};
exports.listen = listen;

},{"../app":1,"../controller/browserSettingsController":3,"../model/config":30}],13:[function(require,module,exports){
/**
 * Edited password events.
 *
 * Used to handle the events related to the edition of a password.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

var TabStorage = require('../model/tabStorage').TabStorage;

var listen = function (worker) {

  /*
   * Set the edited password.
   *
   * @listens passbolt.edit-password.set-edited-password
   * @param requestId {uuid} The request identifier
   * @param editedPassword {array} The edited password
   */
  worker.port.on('passbolt.edit-password.set-edited-password', function (requestId, editedPassword) {
    TabStorage.set(worker.tab.id, 'editedPassword', editedPassword);
    worker.port.emit(requestId, 'SUCCESS');
  });

  /*
   * Get the edited password.
   *
   * @listens passbolt.edit-password.get-edited-password
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.edit-password.get-edited-password', function (requestId) {
    var editedPassword = TabStorage.get(worker.tab.id, 'editedPassword');
    worker.port.emit(requestId, 'SUCCESS', editedPassword);
  });

};
exports.listen = listen;
},{"../model/tabStorage":43}],14:[function(require,module,exports){
/**
 * File Listeners
 * Event related to file like open and save
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var fileController = require('../controller/fileController');

var listen = function (worker) {

  /*
   * Get the preferred download directory.
   *
   * @listens passbolt.keyring.generateKeyPair
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.file.getPreferredDownloadDirectory', function (requestId) {
    fileController.getPreferredDownloadsDirectory().then(
      function (downloadsDirectory) {
        worker.port.emit(requestId, 'SUCCESS', downloadsDirectory);
      },
      function (error) {
        worker.port.emit(requestId, 'ERROR', error.message);
      }
    );
  });

  /*
   * Prompt a file.
   *
   * @listens passbolt.keyring.generateKeyPair
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.file.prompt', function (requestId) {
    fileController.openFile().then(
      function (fileContent) {
        worker.port.emit(requestId, 'SUCCESS', fileContent);
      },
      function (error) {
        worker.port.emit(requestId, 'ERROR', error.message);
      }
    );
  });
};
exports.listen = listen;
},{"../controller/fileController":5}],15:[function(require,module,exports){
/**
 * Group autocomplete Listeners
 *
 * Used to select a user to add to a group.
 *
 * @copyright (c) 2017-present Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

var Worker = require('../model/worker');
var TabStorage = require('../model/tabStorage').TabStorage;
var GroupForm = require('../model/groupForm').GroupForm;

var listen = function (worker) {
    /*
     * A user has been selected to share the secret with.
     *
     * @listens passbolt.share-autocomplete.user-selected
     * @param user {array} The selected user
     */
    worker.port.on('passbolt.group.edit-autocomplete.user-selected', function (user) {
        var groupForm = new GroupForm(worker.tab.id);

        groupForm.addGroupUser(user)
            .then(function(groupUser) {
                // Add user in the list of group users.
                Worker.get('App', worker.tab.id).port.emit('passbolt.group.edit.add-user', groupUser);
            });

        // Reset the autocomplete field.
        Worker.get('GroupEdit', worker.tab.id).port.emit('passbolt.group.edit.reset');
    });
};
exports.listen = listen;

},{"../model/groupForm":35,"../model/tabStorage":43,"../model/worker":45}],16:[function(require,module,exports){
/**
 * Group Listeners
 *
 * Used for handling groups / group edits
 *
 * @copyright (c) 2017-present Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

var Worker = require('../model/worker');
var User = require('../model/user').User;
var Group = require('../model/group').Group;
var GroupForm = require('../model/groupForm').GroupForm;
var TabStorage = require('../model/tabStorage').TabStorage;
// var _ = require('../vendors/underscore-min');

var Keyring = require('../model/keyring').Keyring;
var Crypto = require('../model/crypto').Crypto;
var masterPasswordController = require('../controller/masterPasswordController');
const defer = require('../sdk/core/promise').defer;

var listen = function (worker) {
    /*
     * Initialize the group edit process.
     *
     * If groupId is provided, will load the group info from the server and inform App, which will in turn inform the client.
     *
     * @listens passbolt.app.group-edit-init
     * @param groupId {uuid} The group id, null if creation
     */
    worker.port.on('passbolt.group.edit.init', function (requestId, data) {
        var groupId = data.groupId,
            groupForm = new GroupForm(worker.tab.id);

        if (groupId != '') {
            var group = new Group();
            group.findById(groupId)
                .then(
                    function success(group) {
                        groupForm.init('edit', group);
                        var appWorker = Worker.get('App', worker.tab.id);
                        appWorker.port.emit('passbolt.group.edit.group_loaded', group);
                    },
                    function error(errorResponse) {
                        // TO DO.
                    }
                );
        }
        else {
            groupForm.init('create');
        }

        worker.port.emit(requestId, 'SUCCESS');
    });

    /*
     * Search users that could be added to a group.
     * Once the search has been completed, send the users to the autocomplete
     * worker.
     *
     * @listens passbolt.group.search-users
     * @param keywords {string} The keywords to search
     */
    worker.port.on('passbolt.group.edit.search-users', function (keywords) {
        var //sharedPassword = TabStorage.get(worker.tab.id, 'sharedPassword'),
            user = new User(),
            autocompleteWorker = Worker.get('GroupEditAutocomplete', worker.tab.id),
            // The users that have already been added to the share list should be
            // excluded from the search.
            groupForm = new GroupForm(worker.tab.id),
            excludedUsers = [];

        // If no keywords provided, hide the autocomplete component.
        if (!keywords) {
            autocompleteWorker.port.emit('passbolt.group.edit-autocomplete.reset');
        }
        // Otherwise, search the users who match the keywords,
        // and display them in the autocomplete component.
        else {
            autocompleteWorker.port.emit('passbolt.group.edit-autocomplete.loading');

            // Get existing users.
            var groupUsers = groupForm.get('currentGroup.GroupUser');
            excludedUsers = _.pluck(groupUsers, 'user_id');

            // Search available users.
            user.searchUsers(keywords, excludedUsers)
                .then(function(users) {
                    autocompleteWorker.port.emit('passbolt.group.edit-autocomplete.load-users', users);
                }, function(e) {
                    console.error(e);
                });
        }
    });

    /**
     * Encrypt a list of secrets after a response from a dry-run call.
     * @param group
     *   the group response returned from a dry-run call.
     */
    var encryptSecrets = function (group) {
        var deferred = defer();

        // nothing to do, we can return immediately.
        if (group['dry-run'] == undefined || group['dry-run'] == 0 || group['dry-run']['SecretsNeeded'] == 0) {
            deferred.resolve([]);
            return deferred.promise;
        }

        var secretsToEncrypt = group['dry-run']['SecretsNeeded'],
            mySecrets = group['dry-run']['Secrets'];

        // Encrypt secrets.
        var keyring = new Keyring(),
            crypto = new Crypto(),
            progressWorker = Worker.get('Progress', worker.tab.id),
            progress = 0,
            progressItemsCount = secretsToEncrypt.length * 2;

        // Master password required to decrypt secrets before re-encrypting them.
        masterPasswordController.get(worker).then(function (masterPassword) {
        // Once the master password retrieved, decrypt the secret.

            // Open the progress dialog.
            worker.port.emit('passbolt.progress.open-dialog', 'Encrypting ...', progressItemsCount);
            var promises = [];

            mySecrets.forEach(function(mySecret, i) {
                var p = crypto.decrypt(mySecrets[i].Secret[0].data, masterPassword);
                promises.push(p);
                // Update the progress dialog.
                p.then(function (data) {
                    mySecrets[i].Secret[0].dataClear = data;
                    progress++;
                    if (progressWorker != null) {
                        progressWorker.port.emit('passbolt.progress.update', 'Decrypted ' + mySecrets[i].Resource.name, progress);
                    }
                });
            });
            return Promise.all(promises);
        })
        .then(function(data) {
            // Sync the keyring with the server.
            keyring.sync().then(function () {
                // Once the keyring is synced, encrypt the secret for each user.

                // Store the encryption promise for each user in this array.
                // Encryptions will be treated in parallel to optimize the treatment.
                var promises = [];

                secretsToEncrypt.forEach(function (secretToEncrypt, index) {
                    // Retrieve password.
                    var userId = secretToEncrypt['Secret'].user_id;
                    // Search password in clear.
                    var passwordClear = '';
                    mySecrets.forEach(function(mySecret, index1) {
                        if(secretToEncrypt['Secret'].resource_id == mySecrets[index1]['Secret'][0].resource_id) {
                            passwordClear = mySecrets[index1]['Secret'][0].dataClear;
                        }
                    });

                    var p = crypto.encrypt(passwordClear, userId);
                    promises.push(p);

                    // Update the progress dialog.
                    p.then(function (encryptedData) {
                        // Add the encrypted part to the secret.
                        secretsToEncrypt[index]['Secret'].data = encryptedData;

                        // Update progress bar.
                        progress++;
                        if (progressWorker != null) {
                            progressWorker.port.emit('passbolt.progress.update', 'Encrypted for ' + userId, progress);
                        }
                    });
                });

                return Promise.all(promises);
            })

            // Once the secret is encrypted for all users notify the application and
            // close the progress dialog.
            .then(function (data) {
                deferred.resolve(secretsToEncrypt);
                worker.port.emit('passbolt.progress.close-dialog');
            });
        });

        return deferred.promise;
    };

    /*
     * Saves / update a group.
     * Receives the instruction from the app that the group is ready to be saved.
     * The plugin already knows the list of groupUsers, which is stored in
     * the local storage by the groupForm model.
     *
     * @listens passbolt.group.edit.save
     * @param group {object}
     *   a group object, with name only.
     */
    worker.port.on('passbolt.group.edit.save', function (requestId, groupToSave) {
        // Get groupForm object.
        var groupForm = new GroupForm(worker.tab.id),
            currentGroup = groupForm.get().currentGroup;

        // Set group name.
        groupForm.set('currentGroup.Group.name', groupToSave.name);

        // Get Json for save.
        var groupJson = groupForm.getPostJson(),
            group = new Group(),
            groupUserChangeList = groupForm.getGroupUsersChangeList(),
            isGroupUserCreated = _.where(groupUserChangeList, {status: "created"}).length > 0 ? true : false, // Check if a groupUser is created in the operation.
            isEdit = currentGroup.Group.id != undefined && currentGroup.Group.id != ''; // Check if it's an edit operation, or a create one.


        // In case of existing group, update it.
        if (isEdit) {
            // If no groupUser has been created, make a direct call to save. We do not need a dry-run, so we save one call.
            if (!isGroupUserCreated) {
                group.save(groupJson, currentGroup.Group.id).then(
                    function(groupSaved) {
                        worker.port.emit(requestId, 'SUCCESS', groupSaved);
                    },
                    function error(error) {
                        worker.port.emit(requestId, 'ERROR', error);
                    });
            }
            // Else, if a groupUser has been created, we need to call dry-run first.
            else {
                // Save group in dry-run.
                // The result of this operation will provide us with the list of passwords to encrypt and provide
                // for the actual save.
                group.save(groupJson, currentGroup.Group.id, true)
                    .then(
                        function success(groupDryRun) {
                            // Encrypt secrets for all users.
                            encryptSecrets(groupDryRun).then(function(secrets) {
                                groupJson['Secrets'] = secrets;
                                group.save(groupJson, currentGroup.Group.id).then(
                                    function(groupSaved) {
                                        worker.port.emit(requestId, 'SUCCESS', groupSaved);
                                    },
                                    function error(error) {
                                        worker.port.emit(requestId, 'ERROR', error);
                                    });
                            });
                        },
                        function error(errorResponse) {
                            worker.port.emit(requestId, 'ERROR', errorResponse);
                        }
                    );
            }
        }
        // Create case.
        else {
            group.save(groupJson)
                .then(
                    function success(group) {
                        worker.port.emit(requestId, 'SUCCESS', group);
                    },
                    function error(errorResponse) {
                        worker.port.emit(requestId, 'ERROR', errorResponse);
                    }
                );
        }
    });

    /*
     * A groupUser has been temporary deleted.
     * Remove it from the list of group users, it added
     * previously.
     *
     * @listens passbolt.group.edit.remove-group_user
     * @param groupUser {string} The groupUser that has been removed.
     */
    worker.port.on('passbolt.group.edit.remove-group_user', function (requestId, groupUser) {
        var groupForm = new GroupForm(worker.tab.id);
        groupForm.deleteGroupUser(groupUser).then(
            function(groupUser) {
                worker.port.emit(requestId, 'SUCCESS', groupUser);
            },
            function(error) {
                worker.port.emit(requestId, 'ERROR', error);
            }
        );
    });

    /*
     * A groupUser has been temporary deleted.
     * Remove it from the list of group users, it added
     * previously.
     *
     * @listens passbolt.group.edit.remove-group_user
     * @param groupUser {string} The groupUser that has been removed.
     */
    worker.port.on('passbolt.group.edit.edit-group_user', function (requestId, groupUser) {
        var groupForm = new GroupForm(worker.tab.id),
            appWorker = Worker.get('App', worker.tab.id);

        groupForm.updateGroupUser(groupUser).then(
            function(groupUser) {
                worker.port.emit(requestId, 'SUCCESS', groupUser);
            },
            function(error) {
                worker.port.emit(requestId, 'ERROR', error);
            }
        );
    });

    /*
     * A groupUser has been modified in the groupUsers list.
     *
     * @listens passbolt.group.edit.get_group_users_change_list
     */
    worker.port.on('passbolt.group.edit.get_group_users_change_list', function (requestId) {
        var groupForm = new GroupForm(worker.tab.id),
            changeList = groupForm.getGroupUsersChangeList();
        worker.port.emit(requestId, 'SUCCESS', changeList);
    });
};
exports.listen = listen;
},{"../controller/masterPasswordController":6,"../model/crypto":31,"../model/group":34,"../model/groupForm":35,"../model/keyring":37,"../model/tabStorage":43,"../model/user":44,"../model/worker":45,"../sdk/core/promise":60}],17:[function(require,module,exports){
/**
 * Keyring events
 * @TODO refactor with public and private listeners separate
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var __ = require('../sdk/l10n').get;

var Keyring = require('../model/keyring').Keyring;
var Key = require('../model/key').Key;
var Config = require('../model/config');
var keyring = new Keyring();
var key = new Key();

var fileController = require('../controller/fileController');

var listen = function (worker) {

  /* ==================================================================================
   *  Get Key info events
   * ================================================================================== */

  /*
   * Get the public key information.
   *
   * @listens passbolt.keyring.public.info
   * @param requestId {uuid} The request identifier
   * @param publicKeyArmored {string} The public key
   */
  worker.port.on('passbolt.keyring.public.info', function (requestId, publicKeyArmored) {
    try {
      var info = keyring.keyInfo(publicKeyArmored);
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message);
      return;
    }

    if (typeof info !== 'undefined') {
      worker.port.emit(requestId, 'SUCCESS', info);
    } else {
      worker.port.emit(requestId, 'ERROR');
    }
  });

  /*
   * Get a user's public key.
   *
   * @listens passbolt.keyring.public.get
   * @param requestId {uuid} The request identifier
   * @param userId {string} The user to retrieve the public key
   */
  worker.port.on('passbolt.keyring.public.get', function (requestId, userId) {
    var publicKey = keyring.findPublic(userId);
    if (typeof publicKey !== 'undefined') {
      worker.port.emit(requestId, 'SUCCESS', publicKey);
    } else {
      worker.port.emit(requestId, 'ERROR');
    }
  });

  /*
   * Get the user private key.
   *
   * @listens passbolt.keyring.private.get
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.keyring.private.get', function (requestId) {
    var info = keyring.findPrivate();
    if (typeof info !== 'undefined') {
      worker.port.emit(requestId, 'SUCCESS', info);
    } else {
      worker.port.emit(requestId, 'ERROR');
    }
  });

  /*
   * Get the server's public key.
   *
   * @listens passbolt.keyring.server.get
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.keyring.server.get', function (requestId) {

    var user = new (require('../model/user').User)(),
      Crypto = require('../model/crypto').Crypto,
      serverkeyid = Crypto.uuid(user.settings.getDomain()),
      serverkey = keyring.findPublic(serverkeyid);

    if (typeof serverkey !== 'undefined') {
      worker.port.emit(requestId, 'SUCCESS', serverkey);
    } else {
      worker.port.emit(requestId, 'ERROR');
    }
  });

  /*
   * Extract the public key from a private armored key.
   *
   * @listens passbolt.keyring.public.extract
   * @param requestId {uuid} The request identifier
   * @param privateKeyArmored {string} The private armored key
   */
  worker.port.on('passbolt.keyring.public.extract', function (requestId, privateKeyArmored) {
    var publicKeyArmored = keyring.extractPublicKey(privateKeyArmored);
    if (typeof publicKeyArmored !== 'undefined') {
      worker.port.emit(requestId, 'SUCCESS', publicKeyArmored);
    } else {
      worker.port.emit(requestId, 'ERROR');
    }
  });

  /*
   * Validate the key information.
   *
   * @listens passbolt.keyring.key.validate
   * @param requestId {uuid} The request identifier
   * @param keyData {array} The key information
   * @param fields {array} The names of the variable to validate
   */
  worker.port.on('passbolt.keyring.key.validate', function (requestId, keyData, fields) {
    try {
      var validate = key.validate(keyData, fields);
      worker.port.emit(requestId, 'SUCCESS', validate);
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message, e.validationErrors);
    }
  });

  /* ==================================================================================
   *  Import Key & Sync' events
   * ================================================================================== */

  /*
   * Import the user private armored key.
   *
   * @listens passbolt.keyring.private.import
   * @param requestId {uuid} The request identifier
   * @param privateKeyArmored {string} The private armored key to import
   */
  worker.port.on('passbolt.keyring.private.import', function (requestId, privateKeyArmored) {
    try {
      keyring.importPrivate(privateKeyArmored);
      worker.port.emit(requestId, 'SUCCESS');
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', privateKeyArmored)
    }
  });

  /*
   * Import a user's public armored key.
   *
   * @listens passbolt.keyring.public.import
   * @param requestId {uuid} The request identifier
   * @param publicKeyArmored {string} The public armored key to import
   * @param userId {string} The user identifier
   */
  worker.port.on('passbolt.keyring.public.import', function (requestId, publicKeyArmored, userid) {
    try {
      keyring.importPublic(privateKeyArmored, userid);
      worker.port.emit(requestId, 'SUCCESS');
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message)
    }
  });

  /*
   * Import the server public armored key.
   *
   * @listens passbolt.keyring.server.import
   * @param requestId {uuid} The request identifier
   * @param publicKeyArmored {string} The public armored key to import
   */
  worker.port.on('passbolt.keyring.server.import', function (requestId, publicKeyArmored) {
    try {
      var user = new (require('../model/user').User)();
      keyring.importServerPublicKey(publicKeyArmored, user.settings.getDomain());
      worker.port.emit(requestId, 'SUCCESS');
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message)
    }
  });

  /*
   * Synchronize the keyring with the server.
   *
   * @listens passbolt.keyring.sync
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.keyring.sync', function (requestId) {
    keyring.sync()
      .then(function (keysCount) {
        worker.port.emit(requestId, 'SUCCESS', keysCount);
      });
  });

  /*
   * Check the private key passphrase.
   *
   * @listens passbolt.keyring.private.checkpassphrase
   * @param requestId {uuid} The request identifier
   * @param passphrase {string} The passphrase to check
   */
  worker.port.on('passbolt.keyring.private.checkpassphrase', function (requestId, passphrase) {
    keyring.checkPassphrase(passphrase).then(
      function () {
        worker.port.emit(requestId, 'SUCCESS');
      },
      function (error) {
        worker.port.emit(requestId, 'ERROR',
          __('This is not a valid passphrase'));
      }
    );
  });

  /* ==================================================================================
   *  Generate and backups key events
   * ================================================================================== */

  /*
   * Offer to the user to backup their key by downloading it.
   *
   * @listens passbolt.keyring.key.backup
   * @param requestId {uuid} The request identifier
   * @param key {string} The key to backup
   * @param filename {string} The filename to use for the downloadable file
   */
  worker.port.on('passbolt.keyring.key.backup', function (requestId, key, filename) {

    if (filename == undefined) {
      filename = 'passbolt.asc';
    }
    // If debug mode is enabled, add .txt at the end of filename.
    if (Config.isDebug() == true) {
      filename += '.txt';
    }

    fileController.saveFile(filename, key)
      .then(function () {
        worker.port.emit(requestId, 'SUCCESS');
      }, function () {
        worker.port.emit(requestId, 'ERROR');
      });
  });

  /*
   * Generate a private armored key.
   *
   * @listens passbolt.keyring.generateKeyPair
   * @param requestId {uuid} The request identifier
   * @param keyInfo {array} The key parameters
   * @param passphrase {string} The key passphrase
   */
  worker.port.on('passbolt.keyring.generateKeyPair', function (requestId, keyInfo, passphrase) {
    try {
      keyring.generateKeyPair(keyInfo, passphrase)
        .then(
          function (key) {
            worker.port.emit(requestId, 'SUCCESS', key);
          },
          function (errorMsg) {
            worker.port.emit(requestId, 'ERROR', errorMsg);
          });

    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message);
    }
  });

};
exports.listen = listen;
},{"../controller/fileController":5,"../model/config":30,"../model/crypto":31,"../model/key":36,"../model/keyring":37,"../model/user":44,"../sdk/l10n":61}],18:[function(require,module,exports){
/**
 * Master password Listeners
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var Worker = require('../model/worker');
var Keyring = require('../model/keyring').Keyring;
var TabStorage = require('../model/tabStorage').TabStorage;

var listen = function (worker) {

  /*
   * Master password attempt, verify it :
   * - If correct, resolve the master password request promise with the master password
   *  as parameter.
   *  - If wrong :
   *    * And less than 3 attempts done, notify the user their master password is wrong ;
   *    * And 3 attempts done already
   *      ** notify the user;
   *      ** don't allow him to make another attempt with the same dialog;
   *      ** reject the master password request promise
   *
   * @listens passbolt.master-password.submit
   * @param requestId {uuid} The request identifier
   * @param masterPassword {string} The master password filled by the user
   */
  worker.port.on('passbolt.master-password.submit', function (requestId, masterPassword) {
    var keyring = new Keyring(),
      masterPasswordRequest = TabStorage.get(worker.tab.id, 'masterPasswordRequest');

    // New attempt done.
    masterPasswordRequest.attempts++;

    // Check the master password..
    keyring.checkPassphrase(masterPassword).then(
      // correct master password.
      function () {
        worker.port.emit(requestId, 'SUCCESS');
        masterPasswordRequest.deferred.resolve(masterPassword);
      },
      // wrong master password.
      function () {
        worker.port.emit(requestId, 'ERROR', masterPasswordRequest.attempts);
        if (masterPasswordRequest.attempts == 3) {
          masterPasswordRequest.deferred.reject();
        }
      });
  });

  /*
   * Master password cancel prompt process.
   *  - Close the dialog;
   *  - Reject the master password promise associated to the master password request.
   *
   * @listens passbolt.master-password.cancel
   */
  worker.port.on('passbolt.master-password.cancel', function () {
    var masterPasswordRequest = TabStorage.get(worker.tab.id, 'masterPasswordRequest'),
      appWorker = Worker.get('App', worker.tab.id);

    // If the request hasn't been destroyed already.
    // After reaching 3 attempts the requests is destroyed by the
    // passbolt.master-password.submit message handler.
    if (masterPasswordRequest) {
      masterPasswordRequest.deferred.reject();
    }

    appWorker.port.emit('passbolt.master-password.close-dialog');
  });

};
exports.listen = listen;

},{"../model/keyring":37,"../model/tabStorage":43,"../model/worker":45}],19:[function(require,module,exports){
/**
 * Master password iframe events.
 *
 * It has for aim to control the master password iframe.
 * 	- Add the iframe to the application page. The masterPasswordDialogPagemod
 * 	  will detect it and will display the iframe content.
 * 	- Close the iframe.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var Worker = require('../model/worker');

var listen = function (worker) {

	/*
	 * Open the master password dialog.
	 * @listens passbolt.master-password.open-dialog
	 */
	worker.port.on('passbolt.master-password.open-dialog', function () {
		Worker.get('App', worker.tab.id).port.emit('passbolt.master-password.open-dialog');
	});

	/*
	 * Close the master password dialog.
	 * @listens passbolt.master-password.close-dialog
	 */
	worker.port.on('passbolt.master-password.close-dialog', function () {
		Worker.get('App', worker.tab.id).port.emit('passbolt.master-password.close-dialog');
	});

};
exports.listen = listen;

},{"../model/worker":45}],20:[function(require,module,exports){
/**
 * Passbolt page Listeners
 *
 * Used for workers which require to perform operation on the passbolt page.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

var Worker = require('../model/worker');

var listen = function (worker) {

  /*
   * Notify the passbolt page that a process is currently running on the plugin.
   * When the process is completed, the event
   * passbolt.passbolt-page.loading_complete should be fired.
   *
   * @listens passbolt.passbolt-page.loading
   */
  worker.port.on('passbolt.passbolt-page.loading', function () {
    Worker.get('App', worker.tab.id).port.emit('passbolt.passbolt-page.loading');
  });

  /*
   * Notify the passbolt page that a process has been completed on the plugin.
   *
   * @listens passbolt.passbolt-page.loading_complete
   */
  worker.port.on('passbolt.passbolt-page.loading_complete', function () {
    Worker.get('App', worker.tab.id).port.emit('passbolt.passbolt-page.loading_complete');
  });

  /*
   * Ask the passbolt page to release its focus.
   *
   * @listens passbolt.passbolt-page.remove-all-focuses
   */
  worker.port.on('passbolt.passbolt-page.remove-all-focuses', function () {
    Worker.get('App', worker.tab.id).port.emit('passbolt.passbolt-page.remove-all-focuses');
  });

  /*
   * Ask the passbolt page to add a css class to an HTML Element.
   *
   * @listens passbolt.passbolt-page.add-class
   * @param selector {string} The HTML Element selector
   * @param cssClass {string} The class(es) to add to the html element
   */
  worker.port.on('passbolt.passbolt-page.add-class', function (selector, cssClass) {
    Worker.get('App', worker.tab.id).port.emit('passbolt.passbolt-page.add-class', selector, cssClass);
  });

  /*
   * Ask the passbolt page to remove a css class from an HTML Element.
   *
   * @listens passbolt.passbolt-page.remove-class
   * @param selector {string} The HTML Element selector
   * @param cssClass {string} The class(es) to remove from the html element
   */
  worker.port.on('passbolt.passbolt-page.remove-class', function (selector, cssClass) {
    Worker.get('App', worker.tab.id).port.emit('passbolt.passbolt-page.remove-class', selector, cssClass);
  });

  /*
   * Ask the passbolt page to resize an iframe.
   *
   * @listens passbolt.passbolt-page.resize-iframe
   * @param selector {string} The iframe HTML Element selector
   * @param dimension {object} The new iframe dimension
   */
  worker.port.on('passbolt.passbolt-page.resize-iframe', function (selector, dimension) {
    Worker.get('App', worker.tab.id).port.emit('passbolt.passbolt-page.resize-iframe', selector, dimension);
  });

};
exports.listen = listen;
},{"../model/worker":45}],21:[function(require,module,exports){
/**
 * Secret Listeners
 *
 * Used for encryption and decryption events
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

var masterPasswordController = require('../controller/masterPasswordController');
var Crypto = require('../model/crypto').Crypto;
var Worker = require('../model/worker');
var Secret = require('../model/secret').Secret;
var secret = new Secret();
var TabStorage = require('../model/tabStorage').TabStorage;

var listen = function (worker) {

  /*
   * Validate the edited secret.
   * Notify the secret worker & the application worker so they can display
   * a feedback in case of error.
   *
   * @listens passbolt.secret-edit.validate
   */
  worker.port.on('passbolt.secret-edit.validate', function () {
    // Retrieve the currently edited password.
    var editedPassword = TabStorage.get(worker.tab.id, 'editedPassword');

    try {
      // If the secret is decrypted validate it, otherwise it is
      // considered as valid.
      if (editedPassword.secret != null) {
        secret.validate({data: editedPassword.secret});
      }
      Worker.get('App', worker.tab.id).port.emit('passbolt.secret-edit.validate-success');
      worker.port.emit('passbolt.secret-edit.validate-success');
    } catch (e) {
      Worker.get('App', worker.tab.id).port.emit('passbolt.secret-edit.validate-error', e.message, e.validationErrors);
      worker.port.emit('passbolt.secret-edit.validate-error', e.message, e.validationErrors);
    }
  });

  /*
   * Decrypt a given armored string.
   *
   * @listens passbolt.secret-edit.decrypt
   * @param requestId {uuid} The request identifier
   * @param armored {string} The armored secret
   */
  worker.port.on('passbolt.secret-edit.decrypt', function (requestId, armored) {
    var crypto = new Crypto();

    // Master password required to decrypt a secret.
    masterPasswordController.get(worker)

      // Once the master password retrieved, decrypt the secret.
      .then(function (masterPassword) {
        return crypto.decrypt(armored, masterPassword)
      })

      // Once the secret is decrypted, respond to the requester.
      .then(function (decrypted) {
        worker.port.emit(requestId, 'SUCCESS', decrypted);
      }, function (error) {
        worker.port.emit(requestId, 'ERROR', error);
      });
  });

  /*
   * Listen when the secret is updated.
   * Notify the application. The application needs to know if the secret has
   * changed to
   *
   * @listens passbolt.edit-password.secret-updated
   */
  worker.port.on('passbolt.secret-edit.secret-updated', function () {
    Worker.get('App', worker.tab.id).port.emit('passbolt.secret-edit.secret-updated');
  });

  /*
   * Listen when the secret field has the focus and the user press the tab key.
   * Notify the application. The application will put the focus on the field
   * following the secret field.
   *
   * @listens passbolt.secret-edit.tab-pressed
   */
  worker.port.on('passbolt.secret-edit.tab-pressed', function () {
    Worker.get('App', worker.tab.id).port.emit('passbolt.secret-edit.tab-pressed');
  });

  /*
   * Listen when the secret field has the focus and the user press the back tab
   * key. Notify the application. The application will put the focus on the
   * field above the secret field.
   *
   * @listens passbolt.secret-edit.back-tab-pressed
   */
  worker.port.on('passbolt.secret-edit.back-tab-pressed', function () {
    Worker.get('App', worker.tab.id).port.emit('passbolt.secret-edit.back-tab-pressed');
  });

};
exports.listen = listen;

},{"../controller/masterPasswordController":6,"../model/crypto":31,"../model/secret":40,"../model/tabStorage":43,"../model/worker":45}],22:[function(require,module,exports){
/**
 * Setup bootstrap listener
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var { setInterval, clearInterval } = require('../sdk/timers');
var tabsController = require('../controller/tabsController');
var data = require('../sdk/self').data;
var Worker = require('../model/worker');

var listen = function (worker) {

  /*
   * If the plugin is installed, init the setup.
   *
   * @listens passbolt.setup.completeRecovery
   * @param info {array} The initial setup information
   */
  worker.port.on('passbolt.setup.plugin_check', function (info) {
    var tabId = worker.tab.id;

    // Once the tab is ready, init the setup with the information already gathered.
    var interval = setInterval(function () {
      if (Worker.exists('Setup', tabId)) {
      	Worker.get('Setup', tabId).port.emit('passbolt.setup.init', info);
        clearInterval(interval);
      }
    }, 500);

    // Redirect the user to the second step.
    tabsController.setActiveTabUrl(data.url('setup.html'));
  });

};
exports.listen = listen;

},{"../controller/tabsController":7,"../model/worker":45,"../sdk/self":65,"../sdk/timers":67}],23:[function(require,module,exports){
/**
 * Setup Events
 *
 * Listen to events related to the setup
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var Setup = require('../model/setup').Setup;
var Key = require('../model/key').Key;
var app = require('../app');

var setup = new Setup();

var listen = function (worker) {

  /*
   * Init / Reset the setup.
   *
   * @listens passbolt.setup.init
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.setup.init', function (requestId) {
    setup.reset();
    worker.port.emit(requestId, 'SUCCESS');
  });

  /*
   * Set key info.
   *
   * @listens passbolt.setup.keyinfo.set
   * @param requestId {uuid} The request identifier
   * @param keyData {array} The key information
   */
  worker.port.on('passbolt.setup.keyinfo.set', function (requestId, keyData) {
    try {
      var keyInfo = new Key();
      keyInfo.set(keyData);
      worker.port.emit(requestId, 'SUCCESS');
    } catch (error) {
      worker.port.emit(requestId, 'ERROR', error.message);
    }
  });

  /*
   * Set setup variable.
   *
   * @listens passbolt.setup.set
   * @param requestId {uuid} The request identifier
   * @param key {string} Variable name to store
   * @param value {string} Variable value
   */
  worker.port.on('passbolt.setup.set', function (requestId, key, value) {
    try {
      var setupData = setup.set(key, value);
      worker.port.emit(requestId, 'SUCCESS', setupData);
    } catch (error) {
      worker.port.emit(requestId, 'ERROR', error.message);
    }
  });

  /*
   * Get setup variable.
   *
   * @listens passbolt.setup.get
   * @param requestId {uuid} The request identifier
   * @param key {string} Variable name to store
   */
  worker.port.on('passbolt.setup.get', function (requestId, key) {
    try {
      var setupData = setup.get(key);
      worker.port.emit(requestId, 'SUCCESS', setupData);
    } catch (error) {
      worker.port.emit(requestId, 'ERROR', error.message);
    }
  });

  /*
   * Go to next section in the navigation.
   *
   * @listens passbolt.setup.navigation.next
   * @param requestId {uuid} The request identifier
   * @param stepId {string} The step identifier to go to
   */
  worker.port.on('passbolt.setup.navigation.next', function (requestId, stepId) {
    try {
      var myStepId = setup.navigationNext(stepId);
      worker.port.emit(requestId, 'SUCCESS', myStepId);
    } catch (error) {
      worker.port.emit(requestId, 'ERROR', error.message);
    }
  });

  /*
   * Go back to previous section in the navigation.
   *
   * @listens passbolt.setup.navigation.back
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.setup.navigation.back', function (requestId) {
    try {
      var lastStep = setup.navigationBack();
      worker.port.emit(requestId, 'SUCCESS', lastStep);
    } catch (error) {
      worker.port.emit(requestId, 'ERROR', error.message);
    }
  });

  /*
   * Get the navigation history.
   *
   * @listens passbolt.setup.navigation.get.history
   */
  worker.port.on('passbolt.setup.navigation.get.history', function (requestId) {
    try {
      var history = setup.getNavigationHistory();
      worker.port.emit(requestId, 'SUCCESS', history);
    } catch (error) {
      worker.port.emit(requestId, 'ERROR', error.message);
    }
  });

  /*
   * Flush setup data.
   *
   * @listens passbolt.setup.flush
   */
  worker.port.on('passbolt.setup.flush', function (requestId) {
    try {
      setup.flush();
      worker.port.emit(requestId, 'SUCCESS');
    } catch (error) {
      worker.port.emit(requestId, 'ERROR', error.message);
    }
  });

  /*
   * Check if key exists on server.
   *
   * @listens passbolt.setup.checkKeyExistRemotely
   * @param fingerprint {string} The key fingerprint to check
   */
  worker.port.on('passbolt.setup.checkKeyExistRemotely', function (requestId, fingerprint) {
    try {
      setup.checkKeyExistRemotely(fingerprint)
        .then(
          function () {
            worker.port.emit(requestId, 'SUCCESS');
          },
          function (error) {
            worker.port.emit(requestId, 'ERROR', error.message);
          }
        );
    }
    catch (error) {
      worker.port.emit(requestId, 'ERROR', error.message);
    }
  });

  /*
   * Save the setup gathered information.
   *
   * @listens passbolt.setup.save
   * @param data {arary} The setup information
   */
  worker.port.on('passbolt.setup.save', function (requestId, data) {
    setup.save(data)
      .then(
        function () {
          app.pageMods.PassboltAuth.init();
          worker.port.emit(requestId, 'SUCCESS');
        },
        function (error) {
          worker.port.emit(requestId, 'ERROR', error);
        }
      );
  });

  /*
   * Complete the recovery and the save the gathered information.
   *
   * @listens passbolt.setup.completeRecovery
   * @param data {arary} The recovery information
   */
  worker.port.on('passbolt.setup.completeRecovery', function (requestId, data) {
    setup.completeRecovery(data)
      .then(
        function () {
          app.pageMods.PassboltAuth.init();
          worker.port.emit(requestId, 'SUCCESS');
        },
        function (error) {
          worker.port.emit(requestId, 'ERROR', error);
        }
      );
  });

};
exports.listen = listen;
},{"../app":1,"../model/key":36,"../model/setup":42}],24:[function(require,module,exports){
/**
 * Share autocomplete Listeners
 *
 * Used to select a user to share a password with.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

var Worker = require('../model/worker');
var TabStorage = require('../model/tabStorage').TabStorage;

var listen = function (worker) {

  /*
   * An aro has been selected to share the secret with.
   *
   * @listens passbolt.share-autocomplete.aro-selected
   * @param aro {array} The selected aro (Could be a user or a group)
   */
  worker.port.on('passbolt.share-autocomplete.aro-selected', function (aro) {
    var sharedPassword = TabStorage.get(worker.tab.id, 'sharedPassword');

    // Add the user to the list of user to share the password with.
    var shareWith = TabStorage.get(worker.tab.id, 'shareWith');
    shareWith.push(aro);
    TabStorage.set(worker.tab.id, 'shareWith', shareWith);

    // Add a temporary permission for the selected user.
    var permission = {
      is_new: true,
      aco: 'Resource',
      aco_foreign_key: sharedPassword.resourceId,
      type: 1
    };

    // If adding a permission for a user.
    if(aro.User) {
      permission.aro = 'User';
      permission.aro_foreign_key = aro.User.id;
      permission.User = aro;
    }
    // Else if adding a permission for a group
    else if(aro.Group) {
      permission.aro = 'Group';
      permission.aro_foreign_key = aro.Group.id;
      permission.Group = aro;
    }

    Worker.get('App', worker.tab.id).port.emit('passbolt.share.add-permission', permission);

    // Reset the autocomplete field.
    Worker.get('Share', worker.tab.id).port.emit('passbolt.share.reset');
  });

};
exports.listen = listen;

},{"../model/tabStorage":43,"../model/worker":45}],25:[function(require,module,exports){
/**
 * Share Listeners
 *
 * Used for sharing passwords
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

var Worker = require('../model/worker');
var TabStorage = require('../model/tabStorage').TabStorage;
var Permission = require('../model/permission').Permission;

var listen = function (worker) {

  /*
   * Search users relative to the keywords given as parameter.
   * Once the search has been completed, send the users to the autocomplete
   * worker.
   *
   * @listens passbolt.share.search-users
   * @param keywords {string} The keywords to search
   */
  worker.port.on('passbolt.share.search-users', function (keywords) {
    var sharedPassword = TabStorage.get(worker.tab.id, 'sharedPassword'),
      permission = new Permission(),
      autocompleteWorker = Worker.get('ShareAutocomplete', worker.tab.id);

    // If no keywords provided, hide the autocomplete component.
    if (!keywords) {
      autocompleteWorker.port.emit('passbolt.share-autocomplete.reset');
    }
    // Otherwise, search the users who match the keywords,
    // and display them in the autocomplete component.
    else {
      autocompleteWorker.port.emit('passbolt.share-autocomplete.loading');
      permission.searchUsers('resource', sharedPassword.resourceId, keywords)
        .then(function (aros) {
          // The users & groups that have already been added to the share list should not be displayed.
          var excludedAros = TabStorage.get(worker.tab.id, 'shareWith'),
              excludedArosIds = [];
          // Extract the excluded aros ids.
          if (excludedAros) {
            excludedArosIds = excludedAros.map(function(excludedAro) {
              return excludedAro.User ? excludedAro.User.id : excludedAro.Group.id;
            });
          }

          // Filter the data returned by the API.
          aros = aros.filter(function(aro) {
            var aroId = aro.User ? aro.User.id : aro.Group.id;
            return excludedArosIds.indexOf(aroId) === -1;
          });

          // Load the aros in the autocomplete list.
          autocompleteWorker.port.emit('passbolt.share-autocomplete.load-users', aros);
        }, function (e) {
          // @todo ERROR case not managed
        });
    }
  });

  /*
   * Get the shared password.
   *
   * @listens passbolt.share.get-shared-password
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.share.get-shared-password', function (requestId) {
    var sharedPassword = TabStorage.get(worker.tab.id, 'sharedPassword');
    worker.port.emit(requestId, 'SUCCESS', sharedPassword);
  });

};
exports.listen = listen;

},{"../model/permission":38,"../model/tabStorage":43,"../model/worker":45}],26:[function(require,module,exports){
/**
 * Generic template events
 *
 * Used when a template is requested by the content code and returned by the addon
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var fileController = require('../controller/fileController');

var listen = function (worker) {

  /*
   * Retrieve a template with its path.
   *
   * @listens passbolt.template.get
   * @param requestId {uuid} The request identifier
   * @param path {string} The template path to retrieve
   */
  worker.port.on('passbolt.template.get', function (requestId, path) {
    fileController.loadFile(path)
      .then(function(tpl) {
        worker.port.emit(requestId, 'SUCCESS', tpl);
      },function(error) {
        worker.port.emit(requestId, 'ERROR', error.message);
      });
  });

};
exports.listen = listen;

},{"../controller/fileController":5}],27:[function(require,module,exports){
/**
 * User events
 *
 * Used to handle the events related to the current user
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var app = require('../app');
var User = require('../model/user').User;
var user = new User();
var __ = require('../sdk/l10n').get;

var listen = function (worker) {

  /* ==================================================================================
   *  Getters for user
   * ================================================================================== */

  /*
   * Get the current user as stored in the plugin.
   *
   * @listens passbolt.user.get
   * @param requestId {uuid} The request identifier
   * @param data {array} The user filter
   */
  worker.port.on('passbolt.user.get', function (requestId, data) {
    try {
      var u = user.get(data);
      worker.port.emit(requestId, 'SUCCESS', u);
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message);
    }
  });

  /*
   * Get the current user name (firstname and lastname) as stored in the plugin
   *
   * @listens passbolt.user.get.name
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.user.get.name', function (requestId) {
    try {
      var name = user.getName();
      worker.port.emit(requestId, 'SUCCESS', name);
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message);
    }
  });

  /*
   * Get the current username as stored in the plugin
   *
   * @listens passbolt.user.get.username
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.user.get.username', function (requestId) {
    try {
      var username = user.getUsername();
      worker.port.emit(requestId, 'SUCCESS', username);
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message);
    }
  });

  /*
   * Get all the user settings as stored in the plugin
   *
   * @listens passbolt.user.settings.get
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.user.settings.get', function (requestId) {
    try {
      var settings = user.settings.get();
      worker.port.emit(requestId, 'SUCCESS', settings);
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message);
    }
  });

  /*
   * Get the user security token as stored in the plugin
   *
   * @listens passbolt.user.settings.get.securityToken
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.user.settings.get.securityToken', function (requestId) {
    try {
      var securityToken = user.settings.getSecurityToken();
      worker.port.emit(requestId, 'SUCCESS', securityToken);
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message);
    }
  });

  /*
   * Get the user domain trust as stored in the plugin
   *
   * @listens passbolt.user.settings.get.domain
   * @param requestId {uuid} The request identifier
   */
  worker.port.on('passbolt.user.settings.get.domain', function (requestId) {
    try {
      var domain = user.settings.getDomain();
      worker.port.emit(requestId, 'SUCCESS', domain);
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message);
    }
  });

  /*
   * Validate the user object given and return errors if any.
   *
   * @listens passbolt.user.validate
   * @param requestId {uuid} The request identifier
   * @param u {array} The user object to validate
   * @param fields {array} The fields to validate
   */
  worker.port.on('passbolt.user.validate', function (requestId, u, fields) {
    try {
      var validatedUser = user.validate(u, fields);
      worker.port.emit(requestId, 'SUCCESS', validatedUser);
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message, e.validationErrors);
    }
  });

  /* ==================================================================================
   *  Setters for user
   * ================================================================================== */

  /*
   * Set the user in the plugin local storage
   *
   * @listens passbolt.user.set
   * @param requestId {uuid} The request identifier
   * @param u {array} The user object
   */
  worker.port.on('passbolt.user.set', function (requestId, u) {
    try {
      user.set(u);
      app.pageMods.PassboltAuth.init();
      worker.port.emit(requestId, 'SUCCESS');
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message);
    }
  });

  /*
   * Set the user name in the plugin local storage
   *
   * @listens passbolt.user.set.name
   * @param requestId {uuid} The request identifier
   * @param firstname {string} The user firstname
   * @param lastname {string} The user lastname
   */
  worker.port.on('passbolt.user.set.name', function (requestId, firstname, lastname) {
    try {
      user.setName(firstname, lastname);
      worker.port.emit(requestId, 'SUCCESS');
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.validationErrors);
    }
  });

  /*
   * Set the user username in the plugin local storage
   *
   * @listens passbolt.user.set.username
   * @param requestId {uuid} The request identifier
   * @param username {string} The user username
   */
  worker.port.on('passbolt.user.set.username', function (requestId, username) {
    try {
      user.setUsername(username);
      worker.port.emit(requestId, 'SUCCESS');
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message);
    }
  });

  /*
   * Set the user identifier in the plugin local storage
   *
   * @listens passbolt.user.setId
   * @param requestId {uuid} The request identifier
   * @param userid {string} The user identifier
   */
  worker.port.on('passbolt.user.setId', function (requestId, userid) {
    try {
      user.setId(userid);
      worker.port.emit(requestId, 'SUCCESS');
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message);
    }
  });

  /*
   * Set the user security token in the plugin local storage
   *
   * @listens passbolt.user.settings.set.securityToken
   * @param requestId {uuid} The request identifier
   * @param securityToken {array} The security token
   */
  worker.port.on('passbolt.user.settings.set.securityToken', function (requestId, securityToken) {
    try {
      user.settings.setSecurityToken(securityToken);
      worker.port.emit(requestId, 'SUCCESS');
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message);
    }
  });

  /*
   * Set the user domain trust in the plugin local storage
   *
   * @listens passbolt.user.settings.set.domain
   * @param requestId {uuid} The request identifier
   * @param domain {string} The domain trust
   */
  worker.port.on('passbolt.user.settings.set.domain', function (requestId, domain) {
    try {
      user.settings.setDomain(domain);
      worker.port.emit(requestId, 'SUCCESS');
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message);
    }
  });

  /*
   * Validate the user settings object given and return errors if any.
   *
   * @listens passbolt.user.settings.validate
   * @param requestId {uuid} The request identifier
   * @param settingsData {array} The user settings object to validate
   * @param fields {array} The fields to validate
   */
  worker.port.on('passbolt.user.settings.validate', function (requestId, settingsData, fields) {
    try {
      user.settings.validate(settingsData, fields);
      worker.port.emit(requestId, 'SUCCESS', settingsData);
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message, e.validationErrors);
    }
  });

  /*
   * Remember the master password for some time
   *
   * @listens passbolt.user.rememberMasterPassword
   * @param requestId {uuid} The request identifier
   * @param masterPassword {string} The master password to remember
   * @param seconds {int} The time to remember the secret password
   */
  worker.port.on('passbolt.user.rememberMasterPassword', function (requestId, masterPassword, seconds) {
    try {
      user.storeMasterPasswordTemporarily(masterPassword, seconds);
      worker.port.emit(requestId, 'SUCCESS');
    } catch (e) {
      worker.port.emit(requestId, 'ERROR', e.message);
    }
  });

};
exports.listen = listen;

},{"../app":1,"../model/user":44,"../sdk/l10n":61}],28:[function(require,module,exports){
/**
 * Background script
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
console.log('--------------------------------------------');
console.log('Passbolt Extension: Index.js start ');

// Config and user models
var Config = require('./model/config');
var User = require('./model/user').User;

/* ==================================================================================
 *  Openpgp init
 *  Init web worker
 * ==================================================================================
 */
openpgp.initWorker({
  worker: new Worker(chrome.runtime.getURL('/vendors/openpgp.worker.js'))
});


/* ==================================================================================
 *  Interface changes
 *  Where we affect the look and feel of the firefox instance
 * ==================================================================================
 */
// var ToolbarController = require('./controller/toolbarController').ToolbarController;
// new ToolbarController();

/* ==================================================================================
 *  Page mods init
 *  Run scripts in the context of web pages whose URL matches a given pattern.
 *  see. https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/page-mod
 * ==================================================================================
 */
var pageMods = require('./app').pageMods;

pageMods.Bootstrap.init();

// // If the user is valid we enable the login pagemod
var user = new User();
if (user.isValid()) {
  // Auth pagemod init can also be triggered
  // by debug, setup and user events (e.g. when config change)
  pageMods.PassboltAuth.init();

  // App pagemod init is generally triggered after a successful login
  // We only initialize it here for the cases where the user is already logged in
  user.isLoggedIn()
    .then(function() {
      pageMods.PassboltApp.init();
    });
}

// Setup pagemodsr
pageMods.SetupBootstrap.init();
pageMods.Setup.init();

// Other pagemods active all the time
// but triggered by App or Auth
pageMods.PassboltAuthForm.init();
pageMods.MasterPasswordDialog.init();
pageMods.ProgressDialog.init();
pageMods.SecretEditDialog.init();
pageMods.ShareDialog.init();
pageMods.ShareAutocompleteDialog.init();
pageMods.GroupEditDialog.init();
pageMods.GroupEditAutocompleteDialog.init();

// Debug pagemod
if (Config.isDebug()) {
  pageMods.Debug.init();
}

},{"./app":1,"./model/config":30,"./model/user":44}],29:[function(require,module,exports){
/**
 * Auth model.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var __ = require('../sdk/l10n').get;
const defer = require('../sdk/core/promise').defer;
//
// var fetch = require('../vendors/window').fetch;
// var FormData = require('../vendors/window').FormData;
// const { urldecode, stripslashes } = require('../vendors/phpjs');
// var Validator = require('../vendors/validator');

var Config = require('./config');
var User = require('./user').User;
var Keyring = require('./keyring').Keyring;
var Crypto = require('./crypto').Crypto;
var GpgAuthToken = require('./gpgAuthToken').GpgAuthToken;
var GpgAuthHeader = require('./gpgAuthHeader').GpgAuthHeader;

/**
 * GPGAuth authentication
 * @constructor
 */
var Auth = function () {
  this.URL_VERIFY = '/auth/verify.json'; // @TODO get from server http headers
  this.URL_LOGIN = '/auth/login.json';
  this._verifyToken = undefined;
};

/**
 * Verify the server identify
 *
 * @param serverUrl {string} The server url
 * @param serverKey {string} The server public armored key or keyid
 * @param userFingerprint {string} The user finger print
 * @returns {promise}
 */
Auth.prototype.verify = function(serverUrl, serverKey, userFingerprint) {
  var deferred = defer(),
    _this = this,
    user = new User();

  // if the server key is not provided get it from the settings
  if (typeof serverKey === 'undefined') {
    serverKey = Crypto.uuid(user.settings.getDomain());
  }
  if (typeof serverUrl === 'undefined') {
    serverUrl = user.settings.getDomain();
  }
  if (typeof userFingerprint === 'undefined') {
    var keyring = new Keyring();
    userFingerprint = (keyring.findPrivate()).fingerprint;
  }

  var crypto = new Crypto();
  crypto.encrypt(this.__generateVerifyToken(), serverKey)
    .then(
      function success(encrypted) {
        var data = new FormData();
        data.append('data[gpg_auth][keyid]', userFingerprint);
        data.append('data[gpg_auth][server_verify_token]', encrypted);

        return fetch(
          serverUrl + _this.URL_VERIFY, {
            method: 'POST',
            credentials: 'include',
            body: data
          });
      },
      function error(error) {
        deferred.reject(new Error(__('Unable to encrypt the verify token.') + ' ' + error.message));
      }
    )
    .then(function(response) {
      // Check response status
      var auth = new GpgAuthHeader(response.headers, 'verify');

      // Check that the server was able to decrypt the token with our local copy
      var verify = new GpgAuthToken(auth.headers['x-gpgauth-verify-response']);
      if(verify.token != _this._verifyToken) {
        deferred.reject(new Error(__('The server was unable to prove its identity.')));
      } else {
        deferred.resolve(__('The server identity is verified!'));
      }
    })
    .catch(function(error) {
      deferred.reject(error);
    });

  return deferred.promise;
};

/**
 * Get Server key for GPG auth.
 *
 * @param domain {string} domain where to get the key. if domain is not
 *  provided, then look in the settings.
 *
 * @returns {promise}
 */
Auth.prototype.getServerKey = function (domain) {
  var deferred = defer(),
    user = new User(),
    _this = this;

  if (typeof domain === 'undefined') {
    domain = user.settings.getDomain();
  }

  fetch(
    domain + this.URL_VERIFY, {
      method: 'GET',
      credentials: 'include'
    })
    .then(function(response) {
      _this.__statusCheck(response);
      return response.json();
    })
    .then(
      function success(json) {
        deferred.resolve(json.body);
      },
      function error() {
        deferred.reject(new Error(
          __('There was a problem trying to understand the data provided by the server')));
      }
    )
    .catch(function(error) {
      deferred.reject(error);
    });

  return deferred.promise;
};

/**
 * GPGAuth Login - handle stage1, stage2 and complete
 *
 * @param passphrase {string} The user private key passphrase
 * @returns {promise}
 */
Auth.prototype.login = function(passphrase) {
  var deferred = defer(),
    _this = this,
    keyring = new Keyring();

  keyring.checkPassphrase(passphrase)
    .then(function() {
      return _this.__stage1(passphrase)
    })
    .then(function(userAuthToken) {
      return _this.__stage2(userAuthToken)
    })
    .then(function(referrer) {
      deferred.resolve(referrer);
    })
    .catch(function(error){
      var msg = __('The server was unable to respect the authentication protocol!') + ' ' + error.message;
      deferred.reject(new Error(msg));
    });

  return deferred.promise;
};

/**
 * GPGAuth stage1 - get and decrypt a verification given by the server
 *
 * @param passphrase {string} The user private key passphrase
 * @returns {promise}
 * @private
 */
Auth.prototype.__stage1 = function (passphrase) {
  var deferred = defer(),
    _this = this,
    user = new User(),
    keyring = new Keyring();

  var data = new FormData();
  data.append('data[gpg_auth][keyid]', (keyring.findPrivate()).fingerprint);

  // Stage 1. request a token to the server
  fetch(
    user.settings.getDomain() + this.URL_LOGIN, {
      method: 'POST',
      credentials: 'include',
      body : data
    })
    .then(function (response) {
      // Check response status
      _this.__statusCheck(response);
      var auth = new GpgAuthHeader(response.headers, 'stage1');

      // Try to decrypt the User Auth Token
      var crypto = new Crypto();
      var encryptedUserAuthToken = stripslashes(urldecode(auth.headers['x-gpgauth-user-auth-token']));
      return crypto.decrypt(encryptedUserAuthToken, passphrase);
    })
    .then(function(userAuthToken) {
      // Validate the User Auth Token
      var authToken = new GpgAuthToken(userAuthToken);
      deferred.resolve(authToken.token);
    })
    .catch(function(error){
      deferred.reject(error);
    });

  return deferred.promise;
};

/**
 * Stage 2. send back the token to the server to get auth cookie
 *
 * @param userAuthToken {string} The user authentication token
 * @returns {promise}
 * @private
 */
Auth.prototype.__stage2 = function (userAuthToken) {
  var deferred = defer(),
    _this = this,
    user = new User(),
    keyring = new Keyring();

  var data = new FormData();
  data.append('data[gpg_auth][keyid]', (keyring.findPrivate()).fingerprint);
  data.append('data[gpg_auth][user_token_result]', userAuthToken);

  fetch(
    user.settings.getDomain() + this.URL_LOGIN, {
      method: 'POST',
      credentials: 'include',
      body : data
    })
    .then(function(response) {
      // Check response status
      _this.__statusCheck(response);
      var auth = new GpgAuthHeader(response.headers, 'complete');

      // Get the redirection url
      var referrer = user.settings.getDomain() + auth.headers['x-gpgauth-refer'];
      deferred.resolve(referrer);
    })
    .catch(function(error){
      deferred.reject(error);
    });

  return deferred.promise;
};

/**
 * Generate random verification token to be decrypted by the server
 *
 * @returns {string}
 */
Auth.prototype.__generateVerifyToken = function() {
  var t = new GpgAuthToken();
  this._verifyToken = t.token;
  return this._verifyToken;
};

/**
 * Check if the HTTP status is OK.
 *
 * @param status {int} The http status
 * @returns {boolean}
 * @throw Exception if the status is not OK
 */
Auth.prototype.__statusCheck = function(response) {
  if(!response.ok) {
    var msg = __('There was a problem when trying to communicate with the server') + ' (HTTP Code:' + response.status +')'
    throw new Error(msg);
  }
  return true;
};

// Exports the Authentication model object.
exports.Auth = Auth;
},{"../sdk/core/promise":60,"../sdk/l10n":61,"./config":30,"./crypto":31,"./gpgAuthHeader":32,"./gpgAuthToken":33,"./keyring":37,"./user":44}],30:[function(require,module,exports){
/**
 * Config model.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

// var storage = require('../vendors/node-localstorage').localStorage;
var _config = require('../config/config.json');

/**
 * Init the configuration.
 * Retrieve and load the configuration stored in the local storage.
 */
var init = function () {
  // Retrieve the config from the local storage
  var storedConfig = storage.getItem('config');
  // Retrieve the config defined by the admin in the config.json.
  for (var name in storedConfig) {
    write(name, storedConfig[name], false);
  }
};
exports.init = init;

/**
 * Read a configuration variable.
 *
 * @param name {string} Variable name to obtain
 * @returns {*}
 */
var read = function (name) {
  return _config[name];
};
exports.read = read;

/**
 * Read all configuration variables.
 *
 * @returns {array}
 */
var readAll = function () {
  return _config;
};
exports.readAll = readAll;

/**
 * Set a configuration variable.
 *
 * @param name {string} Variable name to store
 * @param value {mixed} Variable value
 * @param store {boolean} (optional) Should the configuration variables be
 *  stored in the local storage. By default true.
 * @returns {boolean}
 */
var write = function (name, value, store) {
  // do not allow to override the debug mode
  if (name === 'debug') {
    return false;
  }
  _config[name] = value;
  if (typeof store === 'undefined' || store) {
    storage.setItem('config', _config);
  }
  return true;
};
exports.write = write;

/**
 * Is debug enabled?
 *
 * @returns {bool}
 */
var isDebug = function () {
  var debug = read('debug');
  if (typeof debug === 'undefined') {
    return false;
  } else {
    return debug;
  }
};
exports.isDebug = isDebug;

/**
 * Flush the local storage config.
 */
var flush = function () {
  storage.removeItem('config');
};
exports.flush = flush;

// Init the config.
init();

},{"../config/config.json":2}],31:[function(require,module,exports){
/**
 * Crypto model.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

const { defer } = require('../sdk/core/promise');

// var openpgp = require('../vendors/openpgp');
// var XRegExp = require('../vendors/xregexp').XRegExp;
// var Validator = require('../vendors/validator');
// var jsSHA = require('../vendors/sha');

var Keyring = require('./keyring').Keyring;
var __ = require('../sdk/l10n').get;
// var randomBytes = require('../vendors/crypto').randomBytes;

/**
 * The class that deals with Passbolt encryption and decryption operations.
 */
var Crypto = function () {
};

/**
 * Generate a random text.
 * @param size {int} The desired random text size.
 * @returns {string}
 */
Crypto.generateRandomHex = function (size) {
  var text = '';
  var possible = 'ABCDEF0123456789';
  var random_array = randomBytes(size);
  for (var i = size; i > 0; i--) {
    text += possible.charAt(Math.floor(random_array[i] % possible.length));
  }
  return text;
};

/**
 * Generate a random uuid.
 * @param seed {string} (optional) The seed to use to generate a predictable uuid
 *  based on its sha1 hashed
 * @returns {string}
 */
Crypto.uuid = function (seed) {
  var hashStr;

  // Generate a random hash if no seed is provided
  if (typeof seed === 'undefined') {
    hashStr = Crypto.generateRandomHex(32);
  }
  else {
    // Create SHA hash from seed.
    var shaObj = new jsSHA('SHA-1', 'TEXT');
    shaObj.update(seed);
    hashStr = shaObj.getHash('HEX').substring(0, 32);
  }
  // Build a uuid based on the hash
  var search = XRegExp('^(?<first>.{8})(?<second>.{4})(?<third>.{1})(?<fourth>.{3})(?<fifth>.{1})(?<sixth>.{3})(?<seventh>.{12}$)');
  var replace = XRegExp('${first}-${second}-3${fourth}-a${sixth}-${seventh}');

  // Replace regexp by corresponding mask, and remove / character at each side of the result.
  var uuid = XRegExp.replace(hashStr, search, replace).replace(/\//g, '');
  return uuid;
};

/**
 * Encrypt a text for a given user id (or an armored key)
 * @param message {string} The text to encrypt
 * @param key {string} The user id or public armored key
 * @return {promise}
 * @throw Exception
 *   in case of key not found, or problem during encryption.
 */
Crypto.prototype.encrypt = function (message, key) {
  var keyring = new Keyring(),
    publicKey = null,
    deferred = defer();

  // if the key is a uuid we get the armored version from the keyring
  if (Validator.isUUID(key)) {
    var keyInfo = keyring.findPublic(key);
    if (!keyInfo) {
      deferred.reject(new Error(__('The public key could not be found for the user')));
      return deferred.promise;
    }
    key = keyInfo.key;
  }

  // parse the armored key
  try {
    publicKey = openpgp.key.readArmored(key);
  } catch (error) {
    return deferred.reject(new Error(__('The public key is not in a valid or supported format.')));
  }

  // Encrypt message.
  openpgp.encrypt({
    publicKeys: publicKey.keys,
    data: message
  }).then(
    function (encrypted) {
      return deferred.resolve(encrypted.data);
    },
    function (error) {
      return deferred.reject(error);
    }
  );

  // Encrypt message.
  return deferred.promise;
};

/**
 * Decrypt an armored text.
 * @param armored The text to decrypt.
 * @param passphrase (optional) The passphrase used to decrypt the private key.
 * @throw Error if something goes wrong in openpgp methods
 * @return promise
 */
Crypto.prototype.decrypt = function (armored, passphrase) {
  var keyring = new Keyring(),
    keyInfo = keyring.findPrivate(),
    privateKey = openpgp.key.readArmored(keyInfo.key).keys[0],
    deferred = defer(),
    self = this;

  if (!privateKey.isDecrypted) {
    openpgp.decryptKey({privateKey: privateKey, passphrase: passphrase})
      .then(function (privateKey) {
        // Openpgp will throw an exception if the message is badly formatted
        var pgpMessage = openpgp.message.readArmored(armored);
        return openpgp.decrypt({privateKey: privateKey.key, message: pgpMessage});
      })
      .then(
        function (decrypted) {
          deferred.resolve(decrypted.data);
        },
        function (error) {
          deferred.reject(error);
        }
      );
  }
  else {
    openpgp.decrypt({privateKey: privateKey, message: pgpMessage})
      .then(
        function (decrypted) {
          deferred.resolve(decrypted.data);
        },
        function (error) {
          deferred.reject(error);
        }
      );
  }

  return deferred.promise;
};

// Make the object available to other scripts
exports.Crypto = Crypto;

},{"../sdk/core/promise":60,"../sdk/l10n":61,"./keyring":37}],32:[function(require,module,exports){
/**
 * Gpg Auth Http Header Model
 *
 * @copyright (c) 2016-onwards Bolt Softwares pvt. ltd.
 * @licence AGPL-3.0 http://www.gnu.org/licenses/agpl-3.0.en.html
 */
"use strict";

var __ = require('../sdk/l10n').get;

/**
 * The class that deals with secrets.
 */
var GpgAuthHeader = function(headers, step) {
  this.headers = {};
  var allowedHeaders = [
    'x-gpgauth-version',
    'x-gpgauth-authenticated',
    'x-gpgauth-progress',
    'x-gpgauth-user-auth-token',
    'x-gpgauth-verify-response',
    'x-gpgauth-refer',
    'x-gpgauth-debug',
    'x-gpgauth-error'
  ];
  var h;
  for (var i=0; i < allowedHeaders.length; i++) {
    h = allowedHeaders[i];
    if (headers.has(h)) {
      this.headers[h] = headers.get(h);
    }
  }
  return this.__validate(step);
};

/**
 * Validate the headers for a given step.
 * @param step {string} The step name to validate
 * @returns {bool}
 * @throw Error
 *   if the common validation failed
 *   if the validation of the step failed
 */
GpgAuthHeader.prototype.__validate = function(step) {
  var error_msg;

  // Checks common to all stages
  var commonChecks = this.__validateCommonAllStage();
  if (commonChecks instanceof Error) {
    throw commonChecks;
  }

  // Check if the headers are correct
  var result = this.__validateByStage(step);
  if (result instanceof Error) {
    throw new Error(result.message);
  }

  return true;
};

/**
 * Common validation rules for all stages.
 *
 * @returns {*} True or Error
 * @private
 */
GpgAuthHeader.prototype.__validateCommonAllStage = function () {
  var error_msg;

  // Check if headers are present
  if (typeof this.headers === 'undefined') {
    return new Error(__('No GPGAuth headers set.'))
  }

  // Check if version is supported
  if (typeof this.headers['x-gpgauth-version'] !== 'string' ||
    this.headers['x-gpgauth-version'] != '1.3.0') {
    return new Error(__('That version of GPGAuth is not supported. (' + this.headers['x-gpgauth-version'] + ')'));
  }

  // Check if there is GPGAuth error flagged by the server
  if (this.headers['x-gpgauth-error'] != undefined) {
    error_msg = this.headers['x-gpgauth-debug'];
    return new Error(error_msg);
  }

  return true;
};

/**
 * Validate the GPGAuth custom HTTP headers of the server response for a given stage.
 *
 * @param stage {string} The stage name to validate
 * @returns {*} True or Error
 */
GpgAuthHeader.prototype.__validateByStage = function (stage) {
  // Stage specific checks
  switch (stage) {
    case 'logout' :
      if (typeof this.headers['x-gpgauth-authenticated'] !== 'string' ||
        this.headers['x-gpgauth-authenticated'] != 'false') {
        return new Error(__('x-gpgauth-authenticated should be set to false during the logout stage'));
      }
      break;
    case 'verify' :
    case 'stage0' :
      if (typeof this.headers['x-gpgauth-authenticated'] !== 'string' ||
        this.headers['x-gpgauth-authenticated'] != 'false') {
        return new Error(__('x-gpgauth-authenticated should be set to false during the verify stage'));
      }
      if (typeof this.headers['x-gpgauth-progress'] !== 'string' ||
        this.headers['x-gpgauth-progress'] != 'stage0') {
        return new Error(__('x-gpgauth-progress should be set to stage0 during the verify stage'));
      }
      if (typeof this.headers['x-gpgauth-user-auth-token'] !== 'undefined') {
        return new Error(__('x-gpgauth-user-auth-token should not be set during the verify stage' + typeof this.headers['x-gpgauth-user-auth-token']));
      }
      if (typeof this.headers['x-gpgauth-verify-response'] !== 'string') {
        return new Error(__('x-gpgauth-verify-response should be set during the verify stage'));
      }
      if (typeof this.headers['x-gpgauth-refer'] !== 'undefined') {
        return new Error(__('x-gpgauth-refer should not be set during verify stage'));
      }
      break;

    case 'stage1' :
      if (typeof this.headers['x-gpgauth-authenticated'] !== 'string' ||
        this.headers['x-gpgauth-authenticated'] != 'false') {
        return new Error(__('x-gpgauth-authenticated should be set to false during stage1'));
      }
      if (typeof this.headers['x-gpgauth-progress'] !== 'string' ||
        this.headers['x-gpgauth-progress'] != 'stage1') {
        return new Error(__('x-gpgauth-progress should be set to stage1'));
      }
      if (typeof this.headers['x-gpgauth-user-auth-token'] === 'undefined') {
        return new Error(__('x-gpgauth-user-auth-token should be set during stage1'));
      }
      if (typeof this.headers['x-gpgauth-verify-response'] !== 'undefined') {
        return new Error(__('x-gpgauth-verify-response should not be set during stage1'));
      }
      if (typeof this.headers['x-gpgauth-refer'] !== 'undefined') {
        return new Error(__('x-gpgauth-refer should not be set during stage1'));
      }
      return true;

    case 'complete':
      if (typeof this.headers['x-gpgauth-authenticated'] !== 'string' ||
        this.headers['x-gpgauth-authenticated'] != 'true') {
        return new Error(__('x-gpgauth-authenticated should be set to true when GPGAuth is complete'));
      }
      if (typeof this.headers['x-gpgauth-progress'] !== 'string' ||
        this.headers['x-gpgauth-progress'] != 'complete') {
        return new Error(__('x-gpgauth-progress should be set to complete during final stage'));
      }
      if (typeof this.headers['x-gpgauth-user-auth-token'] !== 'undefined') {
        return new Error(__('x-gpgauth-user-auth-token should not be set during final stage'));
      }
      if (typeof this.headers['x-gpgauth-verify-response'] !== 'undefined') {
        return new Error(__('x-gpgauth-verify-response should not be set during final stage'));
      }
      if (typeof this.headers['x-gpgauth-refer'] !== 'string') {
        return new Error(__('x-gpgauth-refer should be set during final stage'));
      }
      return true;

    default:
      return new Error(__('Unknown GPGAuth stage'));
  }
};

exports.GpgAuthHeader = GpgAuthHeader;

},{"../sdk/l10n":61}],33:[function(require,module,exports){
/**
 * Gpg Auth Token Model
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence AGPL-3.0 http://www.gnu.org/licenses/agpl-3.0.en.html
 */
"use strict";

var __ = require('../sdk/l10n').get;
var Crypto = require('./crypto').Crypto;
// var Validator = require('../vendors/validator');

/**
 * Constructor
 * @param token {string} The gpg authentication token
 * @throw Exception if the token is not valid
 */
var GpgAuthToken = function (token) {

  if (typeof token === 'undefined') {
    this.token = 'gpgauthv1.3.0|36|';
    this.token += Crypto.uuid();
    this.token += '|gpgauthv1.3.0';
  } else {
    var result = this.validate('token', token);
    if (result === true) {
      this.token = token;
    } else {
      throw result;
    }
  }
};

/**
 * Validate authentication token fields individually.
 * @param field {string} The name of the field to validate
 * @param value {string} The value of the field to validate
 * @return {*} True or Error
 */
GpgAuthToken.prototype.validate = function (field, value) {
  switch (field) {
    case 'token' :
      if (typeof value === 'undefined' || value === '') {
        return new Error(__('The user authentication token cannot be empty'));
      }
      var sections = value.split('|');
      if (sections.length !== 4) {
        return new Error(__('The user authentication token is not in the right format'));
      }
      if (sections[0] !== sections[3] && sections[0] !== 'gpgauthv1.3.0') {
        return new Error(__('Passbolt does not support this GPGAuth version'));
      }
      if (sections[1] !== '36') {
        return new Error(__('Passbolt does not support GPGAuth token nonce longer than 36 characters: ' + sections[2]));
      }
      if (!Validator.isUUID(sections[2])) {
        return new Error(__('Passbolt does not support GPGAuth token nonce that are not UUIDs'));
      }
      return true;
    default :
      return new Error(__('No validation defined for field: ' + field));
  }
};

exports.GpgAuthToken = GpgAuthToken;

},{"../sdk/l10n":61,"./crypto":31}],34:[function(require,module,exports){
/**
 * Group model.
 *
 * @copyright (c) 2017-present Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

var Config = require('./config');
var Settings = require('./settings').Settings;
// var fetch = require('../vendors/window').fetch;
const { defer } = require('../sdk/core/promise');
var __ = require('../sdk/l10n').get;

/**
 * The class that deals with groups.
 */
var Group = function () {
    // see model/settings
    this.settings = new Settings();

    /**
     * Definition of group object.
     *
     * @type {{id: {}, name: {}, GroupUsers: {}}}
     * @private
     */
    this._group = {
        id: '',
        name: '',
        GroupUser: [],
    };
};


/**
 * Find a group by id on the server.
 *
 * @param groupId
 * @returns {*}
 */
Group.prototype.findById = function(groupId) {
    var deferred = defer();

    fetch(
        this.settings.getDomain() + '/groups/' + groupId + '.json', {
            method: 'GET',
            credentials: 'include',
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            }
        })
        .then(function (response) {
            _response = response;
            return response.json();
        })
        .then(function (json) {
            // Check response status.

            // Response is an error. We return the error.
            if(!_response.ok) {
                json.header.status_code = _response.status;
                return deferred.reject(json);
            }

            // Response is ok.
            var group = json.body;
            return deferred.resolve(group);
        })
        .catch(function (error) {
            return deferred.reject(error);
        });

    return deferred.promise;
};

/**
 * Save / update a group.
 * @param object group
 *   the group to create / update in json format, as expected by the server.
 * @param uuid groupId
 *   the groupId, in case of an update. (id provided in group object will not be taken into account).
 * @param bool dryrun
 *   whether this call should be a dry-run or an actual call.
 * @returns {*}
 */
Group.prototype.save = function(group, groupId, dryrun) {

    var deferred = defer(),
        url =  this.settings.getDomain() + '/groups.json',
        method = 'POST',
        groupParamStr = JSON.stringify(group),
        isDryRun = dryrun != undefined && dryrun == true;

    if (groupId != undefined && groupId != '') {
        url = this.settings.getDomain()
            + '/groups/'
            + groupId
            + (isDryRun ? '/dry-run' : '')
            + '.json';
        method = 'PUT';
    }

    fetch(
        url, {
            method: method,
            credentials: 'include',
            body: groupParamStr,
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            }
        })
        .then(function (response) {
            _response = response;
            return response.json();
        })
        .then(function (json) {
            // Check response status.

            // Response is an error. We return the error.
            if(!_response.ok) {
                json.header.status_code = _response.status;
                return deferred.reject(json);
            }

            // Response is ok.
            var group = json.body;
            return deferred.resolve(group);
        })
        .catch(function (error) {
            return deferred.reject(error);
        });

    return deferred.promise;
};

/**
 * Check if a userId exists in the groupUsers of a group.
 * @param group
 * @param userId
 * @returns {*}
 */
Group.checkGroupUserUserIdExists = function(group, userId) {
    for (var i in group.GroupUser) {
        if (group.GroupUser[i].user_id == userId) {
            return group.GroupUser[i];
        }
    }
    return false;
};


// Exports the Group object.
exports.Group = Group;
},{"../sdk/core/promise":60,"../sdk/l10n":61,"./config":30,"./settings":41}],35:[function(require,module,exports){
/**
 * GroupForm model.
 *
 * Helper for creating / updating groups.
 * Provides tools to manage group users and keep track of changes.
 *
 * @copyright (c) 2017-present Passbolt SARL.
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

var Config = require('./config');
var Settings = require('./settings').Settings;
var Group = require('./group').Group;
const { defer } = require('../sdk/core/promise');
var TabStorage = require('../model/tabStorage').TabStorage;
// var jsonQ = require('../vendors/jsonQ').jsonQ;
// var _ = require('../vendors/underscore-min');
var __ = require('../sdk/l10n').get;

/**
 * The class that deals with groups.
 */
var GroupForm = function (tabId) {
    // see model/settings
    this.settings = new Settings();

    // Store tabId.
    this.tabId = tabId;

    /**
     * Definition of group object.
     *
     * @type {{user: {}, key: {}, settings: {}}}
     * @private
     */
    this._groupForm = {
        state: 'create',
        initialGroup: {}, // Group model.
        currentGroup: {}  // Group model.
    };
};

/**
 * Initialize a groupForm model..
 * @param state
 * @param group
 */
GroupForm.prototype.init = function(state, group) {
    if (group == undefined) {
        group = {
            Group: {
                id: '',
                name: '',
            },
            GroupUser: []
        };
    }
    var groupForm = this._groupForm;
    groupForm.state = state;
    groupForm.initialGroup = group;
    groupForm.currentGroup = _.clone(groupForm.initialGroup);
    // Clone GroupUser array.
    groupForm.currentGroup.GroupUser = groupForm.initialGroup.GroupUser.slice(0);

    // Set groupForm in tab storage.
    TabStorage.set(this.tabId, 'groupForm', groupForm);
};

/**
 * Retrieve a groupForm.
 *
 * @param key
 *   key element to retrieve (in the form xxx.xxx)
 *   if not provided, will return the whole groupForm object.
 * @returns {object}
 *   groupForm object
 */
GroupForm.prototype.get = function(key) {
    var groupForm = TabStorage.get(this.tabId, 'groupForm');
    if (key != undefined) {
        key = key.split(".");
        var val = jsonQ.pathValue(groupForm, key);
        if (val == undefined) {
            return '';
        }
        return val;
    }

    return groupForm;
};

/**
 * Set a groupForm key value.
 * @param key
 * @param value
 * @returns {*}
 */
GroupForm.prototype.set = function (key, value) {
    // Get groupForm stored.
    var groupForm = TabStorage.get(this.tabId, 'groupForm');
    key = key.split(".");
    jsonQ.setPathValue(groupForm, key, value);
    TabStorage.set(this.tabId, 'groupForm', groupForm);
    return groupForm;
};


/**
 * Add a group user in the group.
 *
 * @param groupId
 * @returns {*}
 */
GroupForm.prototype.addGroupUser = function(user) {
    var _groupForm = this.get(),
        deferred = defer();

    var groupId = _groupForm.currentGroup.Group.id;
    var groupUsers = _groupForm.currentGroup.GroupUser;
    var initialGroupUsers = _groupForm.initialGroup.GroupUser;

    // Check if there is already one admin.
    var adminExisting = false;
    for (var i in groupUsers) {
        if (groupUsers[i].is_admin == 1) {
            adminExisting = true;
        }
    }

    // Build groupUser object.
    var groupUser= {
        user_id: user.User.id,
        is_admin: adminExisting == true ? 0 : 1,
        User: user
    };

    // Add object to groupUsers list in tab storage.
    groupUsers.push(groupUser);
    this.set('currentGroup.GroupUser', groupUsers);

    deferred.resolve(groupUser, this.getGroupUsersChangeList());
    return deferred.promise;
};

/**
 * remove a group user from the group.
 *
 * @param groupUser
 * @returns {*}
 */
GroupForm.prototype.deleteGroupUser = function(groupUserToDelete) {
    var _groupForm = this.get(),
        groupUsers = _groupForm.currentGroup.GroupUser,
        deferred = defer();

    // Check if there is already one admin, and getthe index
    // of the groupUser we are looking for.
    var adminCount = 0;
    var index = null;
    for (var i in groupUsers) {
        if (groupUsers[i].is_admin == true) {
            adminCount++;
        }
        if (groupUsers[i].user_id == groupUserToDelete.user_id) {
            index = i;
        }
    }

    // If we are trying to delete the last group admin, throw an exception.
    if (groupUserToDelete.is_admin == true &&  adminCount <= 1) {
        deferred.reject('Can not delete last group admin');
        return deferred.promise;
    }

    // remove groupUser from array.
    groupUsers.splice(index, 1);

    this.set('currentGroup.GroupUser', groupUsers);

    deferred.resolve(groupUserToDelete);
    return deferred.promise;
};

/**
 * update a group user in the group.
 *
 * @param groupUser
 * @returns {*}
 */
GroupForm.prototype.updateGroupUser = function(groupUserToUpdate) {
    var _groupForm = this.get(),
        groupUsers = _groupForm.currentGroup.GroupUser,
        deferred = defer();

    // Check if there is already one admin, and getthe index
    // of the groupUser we are looking for.
    var adminCount = 0;
    var index = null;
    for (var i in groupUsers) {
        if (groupUsers[i].is_admin == 1 || groupUsers[i].is_admin == true) {
            adminCount++;
        }
        if (groupUsers[i].user_id == groupUserToUpdate.user_id) {
            index = i;
        }
    }

    // If we are trying to delete the last group admin, throw an exception.
    var isRemoveAdmin = groupUserToUpdate.is_admin == false && groupUsers[index].is_admin == true;
    if (isRemoveAdmin && adminCount <= 1) {
        deferred.reject('Can not delete last group admin');
        return deferred.promise;
    }

    // remove groupUser from array.
    groupUsers[index] = _.clone(groupUsers[index]);
    groupUsers[index].is_admin = groupUserToUpdate.is_admin;

    this.set('currentGroup.GroupUser', groupUsers);

    deferred.resolve(groupUsers[index]);
    return deferred.promise;
}

/**
 * Get change list in groupUsers in the form.
 *
 * Obtain the change list by comparing currentGroupUsers and initialGroupUsers.
 *
 * @returns {Array}
 */
GroupForm.prototype.getGroupUsersChangeList = function() {
    var _groupForm = this.get();
    var initialGroupUsers = _groupForm.initialGroup.GroupUser;
    var currentGroupUsers = _groupForm.currentGroup.GroupUser;

    var changeList = [];

    // Search for created and updated group users.
    // We browse the current group users and compare with the initial ones.
    for (var i in currentGroupUsers) {
        var existingGroupUser = Group.checkGroupUserUserIdExists(_groupForm.initialGroup, currentGroupUsers[i].user_id);
        if (existingGroupUser != false) {
            // Check if it has been created or updated.
            if (existingGroupUser.is_admin != currentGroupUsers[i].is_admin) {
                var groupUser = _.clone(currentGroupUsers[i]);
                groupUser.status = 'updated';
                changeList.push(groupUser);
            }
        }
        else {
            var groupUser = _.clone(currentGroupUsers[i]);
            groupUser.status = 'created';
            changeList.push(groupUser);
        }
    }

    // Search for deleted group users.
    // We browse the initial group users and compare with the current ones.
    for (var i in initialGroupUsers) {
        var existingGroupUser = Group.checkGroupUserUserIdExists(_groupForm.currentGroup, initialGroupUsers[i].user_id);
        if (existingGroupUser == false) {
            var groupUser = _.clone(initialGroupUsers[i]);
            groupUser.status = 'deleted';
            changeList.push(groupUser);
        }
    }

    return changeList;
};

/**
 * Get post json representation of a group for a save operation.
 * @returns Object {{Group: {name: *}, GroupUsers: Array}}
 */
GroupForm.prototype.getPostJson = function() {
    var group = this.get('currentGroup'),
        initialGroup = this.get('initialGroup'),
        changes = this.getGroupUsersChangeList();

    var groupJson = {
        "Group" : {
            name: group.Group.name,
        },
        "GroupUsers": []
    };

    for (var i in changes) {
        var groupUser = null;
        switch(changes[i].status) {
            case 'created':
                groupUser = {
                    user_id : changes[i].user_id,
                    is_admin: changes[i].is_admin,
                };
                break;
            case 'updated':
                groupUser = {
                    id : changes[i].id,
                    is_admin: changes[i].is_admin,
                };
                break;
            case 'deleted':
                groupUser = {
                    id : changes[i].id,
                    delete: '1',
                };
                break;
        }
        if (groupUser != null) {
            groupJson.GroupUsers.push({GroupUser: groupUser});
        }
    }
    return groupJson;
};


// Exports the Group object.
exports.GroupForm = GroupForm;
},{"../model/tabStorage":43,"../sdk/core/promise":60,"../sdk/l10n":61,"./config":30,"./group":34,"./settings":41}],36:[function(require,module,exports){
/**
 * Key model.
 *
 * Provides validation methods for a key.
 * Was created initially to validate the key config before its generation.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
// var Validator = require('../vendors/validator');
var __ = require('../sdk/l10n').get;

/**
 * The class that deals with keys.
 */
var Key = function () {
  // Key data.
  this._key = {
    algorithm: '',
    length: '',
    comment: '',
    ownerName: '',
    ownerEmail: '',
    userId: '',
    passphrase: ''
  };
};

/**
 * Validate key fields individually.
 * @param field {string} The name of the field to validate
 * @param value {string} The value of the field to validate
 * @returns {boolean}
 * @throw Error if the field is not valid
 * @private
 */
Key.prototype.__validate = function (field, value) {
  switch (field) {
    case 'algorithm':
      if (typeof value === 'undefined' || value === '') {
        throw new Error(__('The key algorithm cannot be empty'));
      }
      var supportedAlgorithms = [
        "RSA-DSA"
      ];
      if (supportedAlgorithms.indexOf(value) == -1) {
        throw new Error(__('The key algorithm selected is not supported'));
      }
      break;
    case 'length' :
      if (typeof value === 'undefined' || value === '') {
        throw new Error(__('The length cannot be empty'));
      }
      var supportedLength = [
        "2048"
      ];
      if (supportedLength.indexOf(value) == -1) {
        throw new Error(__('The key length selected is not supported'));
      }
      break;
    case 'comment' :
      // We accept everything except ().
      if (Validator.matches(value, /[()]/)) {
        throw new Error(__('The comment contains invalid characters : ()'));
      }
      break;
    case 'ownerName' :
      if (typeof value === 'undefined' || value === '') {
        throw new Error(__('The owner name cannot be empty'));
      }
      if (!Validator.isAlphanumericSpecial(value)) {
        throw new Error(__('The full name should contain only alphabetical characters and spaces'));
      }
      break;
    case 'ownerEmail' :
      if (!Validator.isEmail(value)) {
        throw new Error(__('The owner email should be a valid email'));
      }
      break;
    case 'userId' :
      if (!Validator.matches(value, /^[0-9A-Za-z\u00C0-\u017F\-' ]+ (\(\[0-9A-Za-z\u00C0-\u017F\-' ]+\)? (<[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}>){1})$/i)) {
        throw new Error(__('The userId should follow a correct format ' + value));
      }
      break;
    case 'passphrase' :
      if (!Validator.isLength(value, 8)) {
        throw new Error(__('The passphrase should be at least 8 characters'));
      }
      break;
    default :
      throw new Error(__('No validation defined for field: ' + field));
      break;
  }
  return true;
};

/**
 * Validate the key settings.
 * @param key {array} The key to validate
 * @param fields {array} The names of the fields to validate
 * @returns {array} The key in case of success
 * @throw Error if the key is not valid
 */
Key.prototype.validate = function (key, fields) {
  if (fields == undefined) {
    fields = ['ownerName', 'ownerEmail', 'userId', 'passphrase', 'comment'];
  }

  var errors = [];
  for (var i in fields) {
    var fieldName = fields[i];
    try {
      this.__validate(fieldName, key[fieldName]);
    } catch (e) {
      var fieldError = {};
      fieldError[fieldName] = e.message;
      errors.push(fieldError);
    }
  }

  if (errors.length > 0) {
    // Return exception with details in validationErrors.
    var e = new Error(__('key could not be validated'));
    // Add validation errors to the error object.
    e.validationErrors = errors;
    throw e;
  }

  return key;
};

/**
 * Set the key settings.
 * @param key {array} The key to set
 * @return {bool} true if successful
 */
Key.prototype.set = function (key) {

  if (typeof key === 'undefined') {
    throw new Error(__('The key cannot be empty'));
  }

  this.setOwnerName(key.ownerName);
  this.setOwnerEmail(key.ownerEmail);
  this.setAlgorithm(key.algorithm);
  this.setComment(key.comment);
  this.setLength(key.length);

  // Handle userId.
  if (key.userId != undefined || key.userId == '') {
    this.setUserId(key.userId);
  }

  return true;
};

/**
 * Set a length for the key.
 * @param length {string} The key length
 * @throw Error when length is not a supported one
 */
Key.prototype.setLength = function (length) {
  this.__validate('length', length);
  this._key.length = length;
  return this._key;
};

/**
 * Set an algorithm for the key.
 * @param algorithm {string} The key algorithm
 * @throw Error when algorithm is not a supported one
 */
Key.prototype.setAlgorithm = function (algorithm) {
  this.__validate('algorithm', algorithm);
  this._key.algorithm = algorithm;
  return this._key;
};

/**
 * Set a comment for the key.
 * @param comment {string} The key comment
 * @throw Error when comment is not a supported one
 */
Key.prototype.setComment = function (comment) {
  this.__validate('comment', comment);
  this._key.comment = comment;
  return this._key;
};


/**
 * Set a user id for the key.
 * @param userId {string} The key user id
 * @throw Error when the user id is not valid
 */
Key.prototype.setUserId = function (userId) {
  this.__validate('userId', userId);
  this._key.userId = userId;
  return this._key;
};

/**
 * Set an owner name for the key.
 * @param ownerName {string} The key owner name
 * @throw Error when owner name is not valid
 */
Key.prototype.setOwnerName = function (ownerName) {
  this.__validate('ownerName', ownerName);
  this._key.ownerName = ownerName;
  return this._key;
};

/**
 * Set an owner email for the key.
 * @param ownerEmail {string} The key owner email
 * @throw Error when the owner email is not valid
 */
Key.prototype.setOwnerEmail = function (ownerEmail) {
  this.__validate('ownerEmail', ownerEmail);
  this._key.ownerEmail = ownerEmail;
  return this._key;
};

/**
 * Set a passphrase for the key.
 * @param passphrase {string} The key passphrase
 * @throw Error when passphrase is not valid
 */
Key.prototype.setPassphrase = function (passphrase) {
  this.__validate('passphrase', passphrase);
  this._key.passphrase = passphrase;
  return this._key;
};

/**
 * Get the key settings.
 * @param fields {array} (optional) An array of key settings, if not provided
 *  return all the key settings
 * @returns {array}
 */
Key.prototype.get = function (fields) {
  var key = {};

  var keyDefaultFields = [
    "userId",
    "length",
    "algorithm",
    "comment",
    "passphrase"
  ];

  if (fields == undefined) {
    fields = keyDefaultFields;
  }

  for (var i in fields) {
    var varName = fields[i];
    key[varName] = this._key[varName];
  }

  return key;
};

/**
 * Get the key length.
 * @return {string}
 */
Key.prototype.getLength = function () {
  return this._key.length;
};

/**
 * Get the key algorithm.
 * @return {string}
 */
Key.prototype.getAlgorithm = function () {
  return this._key.algorithm;
};

/**
 * Get the key comment.
 * @return {string}
 */
Key.prototype.getComment = function () {
  return this._key.comment;
};

/**
 * Get the key user id.
 * @return {string}
 */
Key.prototype.getUserId = function () {
  if (this._key.userId == undefined || this._key.userId == '') {
    this._key.userId = this.buildUserId();
  }
  return this._key.userId;
};

/**
 * Get the key owner name.
 * @return {string}
 */
Key.prototype.getOwnerName = function () {
  return this._key.ownerName;
};

/**
 * Get the key owner email.
 * @return {string}
 */
Key.prototype.getOwnerEmail = function () {
  return this._key.ownerEmail;
};

/**
 * Get the key passphrase.
 * @return {string}
 */
Key.prototype.getPassphrase = function () {
  return this._key.passphrase;
};

/**
 * Build userId from name email and comment, following GPG standard.
 * @returns {*} False if owner name or owner email missing else the user id
 *  as following : OwnerName (Comment) <OwnerEmail>
 */
Key.prototype.buildUserId = function () {
  if (this._key.ownerName == undefined || this._key.ownerEmail == undefined) {
    return false;
  }
  var userId = '';
  userId += this._key.ownerName;
  userId += this._key.comment != undefined && this._key.comment != '' ?
    (' (' + this._key.comment + ')') : '';
  userId += (' <' + this._key.ownerEmail + '>');

  return userId;
};

// Exports the Key object.
exports.Key = Key;

},{"../sdk/l10n":61}],37:[function(require,module,exports){
/**
 * Keyring model.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
const { defer } = require('../sdk/core/promise');
var __ = require('../sdk/l10n').get;

// var openpgp = require('../vendors/openpgp');
// var fetch = require('../vendors/window').fetch;
// var Validator = require('../vendors/validator');
// var XRegExp = require('../vendors/xregexp').XRegExp;
// var storage = require('../vendors/node-localstorage').localStorage;

var Settings = require('./settings').Settings;
var Key = require('./key').Key;
var keyring = new openpgp.Keyring();

/**
 * The class that deals with Passbolt Keyring.
 */
var Keyring = function () {
};

/**
 * Constants
 * @type {string}
 */
Keyring.PUBLIC_HEADER = '-----BEGIN PGP PUBLIC KEY BLOCK-----';
Keyring.PUBLIC_FOOTER = '-----END PGP PUBLIC KEY BLOCK-----';
Keyring.PRIVATE_HEADER = '-----BEGIN PGP PRIVATE KEY BLOCK-----';
Keyring.PRIVATE_FOOTER = '-----END PGP PRIVATE KEY BLOCK-----';
Keyring.PUBLIC = 'PUBLIC';
Keyring.PRIVATE = 'PRIVATE';
Keyring.MY_KEY_ID = 'MY_KEY_ID'; // @TODO use crypto::uuid(user.id) instead
Keyring.STORAGE_KEY_PUBLIC = 'passbolt-public-gpgkeys';
Keyring.STORAGE_KEY_PRIVATE = 'passbolt-private-gpgkeys';

/**
 * Get private keys.
 *
 * @returns {*}
 */
Keyring.getPrivateKeys = function() {
  // Get the private keys from the local storage.
  var pvtSerialized = storage.getItem(Keyring.STORAGE_KEY_PRIVATE);
  if (pvtSerialized) {
    return JSON.parse(pvtSerialized);
  }
  return {};
};

/**
 * Get stored public keys.
 *
 * @returns {array}
 */
Keyring.getPublicKeys = function () {
  // Get the public keys from the local storage.
  var pubSerialized = storage.getItem(Keyring.STORAGE_KEY_PUBLIC);
  if (pubSerialized) {
    return JSON.parse(pubSerialized);
  }
  return {};
};

/**
 * Store keys in the local storage.
 *
 * @param type {string} The keys type : Keyring.PRIVATE or Keyring.PUBLIC
 * @param keys {array} The list of keys to store
 */
Keyring.prototype.store = function (type, keys) {
  if (type != Keyring.PUBLIC && type != Keyring.PRIVATE) {
    throw new Error(__('Key type is incorrect'));
  }

  if (type == Keyring.PRIVATE) {
    storage_key = Keyring.STORAGE_KEY_PRIVATE;
  } else {
    storage_key = Keyring.STORAGE_KEY_PUBLIC;
  }

  storage.setItem(storage_key, JSON.stringify(keys));
};

/**
 * Flush the Keyring and mark the keyring as not in sync.
 *
 * @param type {string} The type of keys to flush : Keyring.PRIVATE or Keyring.PUBLIC.
 *  Default Keyring.PUBLIC.
 */
Keyring.prototype.flush = function (type) {
  if (typeof type == 'undefined') {
    type = Keyring.PUBLIC;
  }

  if (type == Keyring.PUBLIC) {
    this.store(Keyring.PUBLIC, {});
  }
  else if (type == Keyring.PRIVATE) {
    this.store(Keyring.PRIVATE, {});
  }

  // Removed latestSync variable.
  // We consider that the keyring has never been synced.
  storage.removeItem('latestSync');
};

/**
 * Parse an armored key and extract Public or Private sub string.
 *
 * @param armoredKey {string} The key to parse.
 * @param type {string} The type of keys to parse : Keyring.PRIVATE or Keyring.PUBLIC.
 *  Default Keyring.PRIVATE.
 * @returns {string}
 */
var parseArmoredKey = function (armoredKey, type) {
  // The type of key to parse. By default the PRIVATE.
  var type = type || Keyring.PRIVATE,
  // The parsed key. If no header found the output will be the input.
    key = armoredKey || '';

  if (type == Keyring.PUBLIC) {
    // Check if we find the public header & footer.
    var pubHeaderPos = armoredKey.indexOf(Keyring.PUBLIC_HEADER);
    if (pubHeaderPos != -1) {
      var pubFooterPos = armoredKey.indexOf(Keyring.PUBLIC_FOOTER);
      if (pubFooterPos != -1) {
        key = armoredKey.substr(pubHeaderPos, pubFooterPos + Keyring.PUBLIC_FOOTER.length);
      }
    }
  } else if (type == Keyring.PRIVATE) {
    // Check if we find the private header & footer.
    var privHeaderPos = armoredKey.indexOf(Keyring.PRIVATE_HEADER);
    if (privHeaderPos != -1) {
      var privFooterPos = armoredKey.indexOf(Keyring.PRIVATE_FOOTER);
      if (privFooterPos != -1) {
        key = armoredKey.substr(privHeaderPos, privFooterPos + Keyring.PRIVATE_HEADER.length);
      }
    }
  }

  return key;
};

/**
 * Import a public armored key.
 *
 * @param armoredPublicKey {string} The key to import
 * @param userId {string} The owner of the key
 * @returns {bool}
 * @throw Error
 *  if the key cannot be read by openpgp
 *  if the key is not public
 *  if the user id is not valid
 */
Keyring.prototype.importPublic = function (armoredPublicKey, userId) {
  // Check user id
  if (typeof userId === 'undefined') {
    throw new Error(__('The user id is undefined'));
  }
  if (!Validator.isUUID(userId)) {
    throw new Error(__('The user id is not valid'));
  }

  // Parse the keys. If standard format given with a text containing
  // public/private. It will extract only the public.
  var armoredPublicKey = parseArmoredKey(armoredPublicKey, Keyring.PUBLIC);

  // Is the given key a valid pgp key ?
  var openpgpRes = openpgp.key.readArmored(armoredPublicKey);

  // Return the error in any case
  if (openpgpRes.err) {
    throw new Error(openpgpRes.err[0].message);
  }

  // If the key is not public, return an error.
  var key = openpgpRes.keys[0];
  if (!key.isPublic()) {
    throw new Error(__('Expected a public key but got a private key instead'));
  }

  // Get the keyInfo.
  var keyInfo = this.keyInfo(armoredPublicKey);

  // Add the key in the keyring.
  var publicKeys = Keyring.getPublicKeys();
  publicKeys[userId] = keyInfo;
  publicKeys[userId].user_id = userId;
  this.store(Keyring.PUBLIC, publicKeys);

  return true;
};

/**
 * Import a private armored key.
 *
 * @param armoredKey {string} The key to import
 * @returns {bool}
 * @throw Error
 *  if the key cannot be read by openpgp
 *  if the key is not private
 */
Keyring.prototype.importPrivate = function (armoredKey) {
  // Flush any existing private key.
  this.flush(Keyring.PRIVATE);

  // Parse the keys. If standard format given with a text containing
  // public/private. It will extract only the private.
  var armoredKey = parseArmoredKey(armoredKey, Keyring.PRIVATE);

  // Is the given key a valid pgp key ?
  var openpgpRes = openpgp.key.readArmored(armoredKey);

  // Return the error in any case
  if (openpgpRes.err) {
    throw new Error(openpgpRes.err[0].message);
  }

  // If the key is not private, return an error.
  var key = openpgpRes.keys[0];
  if (!key.isPrivate()) {
    throw new Error(__('Expected a private key but got a public key instead'));
  }

  // Get the keyInfo.
  var keyInfo = this.keyInfo(armoredKey);

  // Add the key in the keyring
  var privateKeys = Keyring.getPrivateKeys();
  privateKeys[Keyring.MY_KEY_ID] = keyInfo;
  privateKeys[Keyring.MY_KEY_ID].user_id = Keyring.MY_KEY_ID;
  this.store(Keyring.PRIVATE, privateKeys);

  return true;
};

/**
 * Import the server public armored key.
 *
 * @param armoredPublicKey {string} The key to import
 * @param domain {string} The server domain url
 * @returns {bool}
 * @throw Error if the key cannot be imported
 */
Keyring.prototype.importServerPublicKey = function (armoredKey, domain) {
  var Crypto = require('../model/crypto').Crypto;
  var serverKeyId = Crypto.uuid(domain);
  this.importPublic(armoredKey, serverKeyId);
  return true;
};

/**
 * Get the key info.
 *
 * @param armoredKey {string} The key to examine
 * @return {array}
 * @throw Error if the key cannot be read by openpgp
 */
Keyring.prototype.keyInfo = function (armoredKey) {
  // Attempt to read armored key.
  var openpgpRes = openpgp.key.readArmored(armoredKey);

  // In case of error, throw exception.
  if (openpgpRes.err) {
    throw new Error(openpgpRes.err[0].message);
  }

  var key = openpgpRes.keys[0],
    userIds = key.getUserIds(),
    userIdsSplited = [];

  if(userIds.length === 0) {
    throw new Error('No key user ID found');
  }

  // Extract name & email from key userIds.
  var myRegexp = XRegExp(/(.*) <(\S+@\S+)>$/g);
  var match;
  for (var i in userIds) {
    match = XRegExp.exec(userIds[i], myRegexp);
    if(match === null) {
      throw new Error('Error when parsing key user id');
    }
    userIdsSplited.push({
      name: match[1],
      email: match[2]
    });
  }

  // seems like opengpg keys id can be longer than 8 bytes (16 default?)
  var keyid = key.primaryKey.getKeyId().toHex();
  if (keyid.length > 8) {
    var shortid = keyid.substr(keyid.length - 8);
    keyid = shortid;
  }

  var info = {
    key: armoredKey,
    keyId: keyid,
    userIds: userIdsSplited,
    fingerprint: key.primaryKey.getFingerprint(),
    algorithm: key.primaryKey.algorithm.substring(0, 3), // @TODO : proper alghorithm parsing
    created: key.primaryKey.created,
    expires: key.getExpirationTime(),
    length: key.primaryKey.getBitSize(),
    private: key.isPrivate()
  };

  return info;
};

/**
 * Extract a public armored key from a private armored key.
 * @param privateArmoredKey {string} The private key armored
 * @returns {string}
 */
Keyring.prototype.extractPublicKey = function (privateArmoredKey) {
  var key = openpgp.key.readArmored(privateArmoredKey);
  var publicKey = key.keys[0].toPublic();
  return publicKey.armor();
};

/**
 * Get a public key by its fingerprint.
 *
 * @param userId {string) The key owner ids
 * @returns {OpenPgpKey}
 */
Keyring.prototype.findPublic = function (userId) {
  var publicKeys = Keyring.getPublicKeys();
  // TODO no need to iterate, use property/key instead
  for (var i in publicKeys) {
    if (publicKeys[i].user_id == userId) {
      return publicKeys[i];
    }
  }
  return undefined;
};

/**
 * Get a private key by its fingerprint.
 * We currently only support one private key per person
 *
 * @param userId {string} The key owner
 * @returns {OpenPgpKey}
 */
Keyring.prototype.findPrivate = function (userId) {
  userId = userId || Keyring.MY_KEY_ID;
  var privateKeys = Keyring.getPrivateKeys();
  return privateKeys[userId];
};

/**
 * Generate a key pair based on given key settings.
 *
 * @param keyInfo {array} The key settings
 * @param passphrase {string} The key passphrase
 * @returns {promise}
 */
Keyring.prototype.generateKeyPair = function (keyInfo, passphrase) {
  // Get user id from key info.
  var key = new Key();
  key.set(keyInfo);
  keyInfo.userId = key.getUserId();

  var keySettings = {
    numBits: keyInfo.length,
    userIds: keyInfo.userId,
    passphrase: passphrase
  };

  // Launch key pair generation from openpgp worker.
  var def = openpgp
    .generateKey(keySettings);

  return def;
};

/**
 * Check if the passphrase is valid for the user private key.
 *
 * @param passphrase {string} The key passphrase
 * @returns {promise}
 */
Keyring.prototype.checkPassphrase = function (passphrase) {
  var deferred = defer(),
    keyInfo = this.findPrivate(),
    privateKey = openpgp.key.readArmored(keyInfo.key).keys[0];

  if (!privateKey.isDecrypted) {
    openpgp.decryptKey({privateKey: privateKey, passphrase: passphrase})
      .then(
        function (decrypted) {
          deferred.resolve(decrypted);
          return deferred.promise;
        },
        function (e) {
          deferred.reject(e.message);
          return deferred.promise;
        }
      );
  }
  else {
    deferred.resolve();
  }
  return deferred.promise;
};

/**
 * Sync the local keyring with the passbolt API.
 * Retrieve the latest updated Public Keys.
 *
 * @returns {promise}
 */
Keyring.prototype.sync = function () {
  var _this = this,
    deferred = defer();

  // Attention : some latencies have been observed while operating on the opengpg keyring.
  var latestSync = storage.getItem('latestSync');

  // Get the latest keys changes from the backend.
  var settings = new Settings();
  var url = settings.getDomain() + '/gpgkeys.json';
  var _response = {};

  // If a sync has already been performed.
  if (latestSync) {
    url += '?modified_after=' + latestSync;
  }

  // Get the updated public keys from passbolt.
  fetch(
    url, {
      method: 'GET',
      credentials: 'include',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      }
    })
    .then(function(response) {
      _response = response;
      return response.json();
    })
    .then(function(json) {
      // Check response status
      if(!_response.ok) {
        var msg = __('Could not synchronize the keyring. The server responded with an error.');
        if(json.headers.msg != undefined) {
          msg += ' ' + json.headers.msg;
        }
        msg += '(' + _response.status + ')';
        return deferred.reject(new Error(msg));
      }

      // Import the keys in keyring
      if (json.body != undefined) {
        // Store all the new keys in the keyring.
        for (var i in json.body) {
          var meta = json.body[i];
          _this.importPublic(meta.Gpgkey.key, meta.Gpgkey.user_id);
        }
      } else {
        return deferred.reject(new Error(
          __('Could not synchronize the keyring. The server response body is missing.')
        ));
      }

      // Update the latest synced time.
      if (json.header != undefined) {
        storage.setItem('latestSync', json.header.servertime);
      } else {
        return deferred.reject(new Error(
          __('Could not synchronize the keyring. The server response header is missing.')
        ));
      }

      // Resolve the defer with the number of updated keys.
      return deferred.resolve(json.body.length);
    })
    .catch(function(error) {
      return deferred.reject(error);
    });

  return deferred.promise;
};

// Exports the Keyring object.
exports.Keyring = Keyring;

},{"../model/crypto":31,"../sdk/core/promise":60,"../sdk/l10n":61,"./key":36,"./settings":41}],38:[function(require,module,exports){
/**
 * Permission model.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

var Config = require('./config');
var Settings = require('./settings').Settings;

const { defer } = require('../sdk/core/promise');
var __ = require('../sdk/l10n').get;

// var Validator = require('../vendors/validator');
// var fetch = require('../vendors/window').fetch;

/**
 * The class that deals with permissions.
 */
var Permission = function () {
	// see model/settings
	this.settings = new Settings();
};

/**
 * Search users that could be granted to access a given resource.
 *
 * @param model {string} The type of instance
 * @param instanceId {string} The instance to search on
 * @param keywords {string} Filter the search on keywords
 * @param excludedUsers {array} Exclude some users from the search result
 * @returns {promise}
 */
Permission.prototype.searchUsers = function(model, instanceId, keywords, excludedUsers) {
	var deferred = defer(),
			_response = {},
			url = null;

	// Check if there is a trusted domain.
	try {
		url = this.settings.getDomain() + '/share/search-users/' + model + '/' + instanceId + '.json';
		url += '?keywords=' + keywords;
	} catch(e) {
		return deferred.reject(__('The application domain is not set'));
	}

	// Retrieve the users from the server.
	fetch(
			url, {
				method: 'GET',
				credentials: 'include',
				headers: {
					'Accept': 'application/json',
					'Content-Type': 'application/json'
				}
			})
			.then(function(response) {
				_response = response;
				return response.json();
			})
			.then(function(json) {
				// Check response status
				if(!_response.ok) {
					var msg = __('Could not get the users. The server responded with an error.');
					if(json.headers.msg != undefined) {
						msg += ' ' + json.headers.msg;
					}
					msg += ' (' + _response.status + ')';
					return deferred.reject(new Error(msg));
				}
				return deferred.resolve(json.body);
			})
			.catch(function(error) {
				return deferred.reject(error);
			});

	return deferred.promise;
};

// Exports the Permission object.
exports.Permission = Permission;

},{"../sdk/core/promise":60,"../sdk/l10n":61,"./config":30,"./settings":41}],39:[function(require,module,exports){
/**
 * Resource model.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var __ = require('../sdk/l10n').get;
const defer = require('../sdk/core/promise').defer;
// var fetch = require('../vendors/window').fetch;

var User = require('./user').User;

/**
 * The class that deals with resources.
 */
var Resource = function () {
};

/**
 * Simulate share permissions update.
 *
 * It is helpful to :
 *  - Ensure that the changes won't compromise the data integrity;
 *  - Get the lists of added and removed users (Used for later encryption).
 *
 * @param resourceId
 * @param permissions
 * @returns {*}
 */
Resource.simulateShare = function (resourceId, permissions) {
  var deferred = defer(),
    user = new User(),
    domain = user.settings.getDomain(),
    body = {Permissions: permissions};

  fetch(
    domain + '/share/simulate/resource/' + resourceId + '.json', {
      method: 'POST',
      credentials: 'include',
      body: JSON.stringify(body),
      headers: {
        'Accept': 'application/json',
        'content-type': 'application/json'
      }
    })
    .then(
      function success(response) {
        response.json()
          .then(function (json) {
            deferred.resolve(json.body);
          });
      },
      function error() {
        deferred.reject(new Error(
          __('There was a problem trying to get the ')));
      }
    );

  return deferred.promise;
};

// Exports the Resource object.
exports.Resource = Resource;

},{"../sdk/core/promise":60,"../sdk/l10n":61,"./user":44}],40:[function(require,module,exports){
/**
 * Secret model.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

// var Validator = require('../vendors/validator');
var __ = require('../sdk/l10n').get;

/**
 * The class that deals with secrets.
 */
var Secret = function () {
};

/**
 * Validate secret fields individually.
 * @param field {string} The field name
 * @param value {*} The field value
 * @returns {boolean}
 * @private
 * @throw Error if the field is not valid
 */
Secret.prototype.__validate = function (field, value) {
  switch (field) {
    case 'data':
      if (Validator.isNull(value)) {
        throw new Error(__('This information is required'))
      }
      break;
    default :
      throw new Error(__('No validation defined for field: ' + field));
      break;
  }
  return true;
};

/**
 * Validate a secret, and return fields with errors in case of failure.
 *
 * @param secret {array} The secret to validate
 * @param fields {array} The names of the fields to validate
 * @returns {bool}
 * @throw Error if the secret is not valid
 */
Secret.prototype.validate = function (secret, fields) {
  if (fields == undefined) {
    fields = ['data'];
  }

  var errors = [];
  for (var i in fields) {
    var fieldName = fields[i];
    try {
      this.__validate(fieldName, secret[fieldName]);
    } catch (e) {
      var fieldError = {};
      fieldError[fieldName] = e.message;
      errors.push(fieldError);
    }
  }

  if (errors.length > 0) {
    // Return exception with details in validationErrors.
    var e = new Error(__('secret could not be validated'));
    // Add validation errors to the error object.
    e.validationErrors = errors;
    throw e;
  }

  return true;
};

// Exports the Secret object.
exports.Secret = Secret;

},{"../sdk/l10n":61}],41:[function(require,module,exports){
/**
 * Settings model.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

var __ = require('../sdk/l10n').get;
var Config = require('./config');
// var Validator = require('../vendors/validator');

/**
 * The class that deals with users settings
 */
var Settings = function () {
};

/**
 * Sanity check on user settings.
 * @return {bool}
 */
Settings.prototype.isValid = function () {
  try {
    this.getSecurityToken();
    this.getDomain();
  } catch (e) {
    return false;
  }
  return true;
};

/**
 * Validate settings fields individually.
 * @param field {string} The field name
 * @param value {*} The field value
 * @returns {boolean}
 * @private
 * @throw Error if the field is not valid
 */
Settings.prototype.__validate = function (field, value) {
  switch (field) {
    case 'securityToken':
      this.__validateSecurityToken(value);
      break;
    case 'domain':
      this.__validateDomain(value);
      break;
    default :
      throw new Error(__('No validation defined for field: ' + field));
      break;
  }
};

/**
 * Validate a security token.
 * @param token {string} The token to validate
 * @returns {boolean}
 * @throw Error on validation failure
 * @private
 */
Settings.prototype.__validateSecurityToken = function (token) {
  if ((typeof token === 'undefined')) {
    throw Error(__('A token cannot be empty'));
  }

  if (typeof token.code === 'undefined' || token.code === '') {
    throw Error(__('A token code cannot be empty'));
  }

  if (!Validator.isAlphanumericSpecial(token.code)) {
    throw new Error(__('The token code should only contain alphabetical and numeric characters'))
  }

  if (!Validator.isLength(token.code, 3, 3)) {
    throw Error(__('The token code should only contain 3 characters'))
  }

  if (typeof token.color === 'undefined' || token.color === '') {
    throw Error(__('The token color cannot be empty'));
  }

  if (!Validator.isHexColor(token.color)) {
    throw Error(__('This is not a valid token color: ' + token.color + '.'));
  }

  if (typeof token.textcolor === 'undefined' || token.textcolor === '') {
    throw Error(__('The token text color cannot be empty'));
  }

  if (!Validator.isHexColor(token.textcolor)) {
    throw Error(__('This is not a valid token text color: ' + token.textcolor + '.'));
  }
  return true;
};

/**
 * Validate a domain.
 * @param domain {string} The domain to validate
 * @returns {boolean}
 * @throw Error on validation failure
 * @private
 */
Settings.prototype.__validateDomain = function (domain) {
  if ((typeof domain === 'undefined' || domain === '')) {
    throw new Error(__('A domain cannot be empty'));
  }
  if (!Validator.isURL(domain)) {
    throw new Error(__('The trusted domain url is not valid'));
  }
  return true;
};

/**
 * Validate a settings object.
 *
 * @param settings {array} The settings to validate
 * @param fields {array} The names of the fields to validate
 * @returns {bool}
 * @throw Error if the secret is not valid
 */
Settings.prototype.validate = function (settings, fields) {
  if (fields == undefined) {
    fields = ['securityToken', 'domain'];
  }

  var errors = [];
  for (var i in fields) {
    var fieldName = fields[i];
    try {
      this.__validate(fieldName, settings[fieldName]);
    } catch (e) {
      var fieldError = {};
      fieldError[fieldName] = e.message;
      errors.push(fieldError);
    }
  }

  if (errors.length > 0) {
    // Return exception with details in validationErrors.
    var e = new Error(__('settings could not be validated'));
    // Add validation errors to the error object.
    e.validationErrors = errors;
    throw e;
  }

  return settings;
};

/**
 * Get the user security token.
 * @returns {string}
 * @throw Error if security token is not set
 */
Settings.prototype.getSecurityToken = function () {
  var token = {};
  token.code = Config.read('user.settings.securityToken.code');
  token.color = Config.read('user.settings.securityToken.color');
  token.textcolor = Config.read('user.settings.securityToken.textColor');

  if ((typeof token.code === 'undefined') ||
    (typeof token.color === 'undefined') ||
    (typeof token.textcolor === 'undefined')) {
    throw new Error(__('Security token is not set'));
  }
  return token;
};

/**
 * Set the user security token.
 * @param token {string} The security token
 * @return {bool}
 * @throw Error if security token is not valid
 */
Settings.prototype.setSecurityToken = function (token) {
  this.__validateSecurityToken(token);
  Config.write('user.settings.securityToken.code', token.code);
  Config.write('user.settings.securityToken.color', token.color);
  Config.write('user.settings.securityToken.textColor', token.textcolor);
  return true;
};

/**
 * Set a domain that the plugin can trust.
 * @param domain {string} The domain
 * @throw Error if domain is not a valid
 */
Settings.prototype.setDomain = function (domain) {
  this.__validateDomain(domain);
  return Config.write('user.settings.trustedDomain', domain);
};

/**
 * Get the trusted domain.
 * @returns {string}
 * @throw Error if the trusted domain is not set
 */
Settings.prototype.getDomain = function () {
  var domain = Config.read('user.settings.trustedDomain');

  if (typeof domain === 'undefined') {
    if (!Config.isDebug()) {
      throw new Error(__('Trusted domain is not set'));
    } else {
      domain = Config.read('baseUrl');
      if (typeof domain === 'undefined') {
        throw new Error(__('Base url not found in config'));
      }
    }
  }
  return domain;
};

/**
 * Get the settings.
 * @param fields {array} (optional) An array of settings fields, if not provided
 *  return all the settings
 * @returns {array}
 */
Settings.prototype.get = function (fields) {
  var settings = {};

  var settingsDefaultFields = [
    "domain",
    "securityToken"
  ];

  if (typeof fields == 'undefined') {
    fields = settingsDefaultFields;
  }

  if (fields.indexOf("domain") != -1) {
    settings.domain = this.getDomain();
  }
  if (fields.indexOf("securityToken") != -1) {
    settings.securityToken = this.getSecurityToken();
  }

  return settings;
};

/**
 * Set all the settings at once.
 * @param settings {array} The settings to set
 * @returns {boolean}
 * @throw Error if settings is empty or doesn't validate
 */
Settings.prototype.set = function (settings) {
  if (typeof settings === 'undefined') {
    throw new Error(__('Settings cannot be empty'));
  }
  this.setSecurityToken(settings.securityToken);
  this.setDomain(settings.domain);
  return true;
};

/**
 * Flush the user settings
 */
Settings.prototype.flush = function () {
  Config.flush();
};

exports.Settings = Settings;
},{"../sdk/l10n":61,"./config":30}],42:[function(require,module,exports){
/**
 * Setup model.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
const { defer } = require('../sdk/core/promise');
var __ = require('../sdk/l10n').get;

var Config = require('./config');
var Keyring = require('./keyring').Keyring;
var Crypto = require('./crypto').Crypto;
var Auth = require('./auth').Auth;
var User = require('./user').User;

// var storage = require('../vendors/node-localstorage').localStorage;
// var jsonQ = require('../vendors/jsonQ').jsonQ;
// var Validator = require('../vendors/validator');
// var fetch = require('../vendors/window').fetch;
// var FormData = require('../vendors/window').FormData;

/**
 * The class that deals with keys.
 */
var Setup = function () {
  /**
   * Definition of setup object.
   *
   * @type {{user: {}, key: {}, settings: {}}}
   * @private
   */
  this._setup = {
    stepId: '',
    stepsHistory: '',
    user: {},
    key: {},
    settings: {
      token: '',
      domain: '',
      securityToken: {},
      armoredServerKey: ''
    }
  };

  this.storageKeyName = 'setup';
};

/**
 * Set setup variable in storage.
 *
 * @param key {string} The variable name
 * @param value {*} The variable value
 * @returns {*}
 */
Setup.prototype.set = function (key, value) {
  // Get last setup stored.
  var _setup = storage.getItem(this.storageKeyName);
  if (_setup == undefined || _setup == null) {
    _setup = JSON.parse(JSON.stringify(this._setup));
  }
  key = key.split(".");
  jsonQ.setPathValue(_setup, key, value);
  storage.setItem(this.storageKeyName, _setup);
  return _setup;
};

/**
 * Set setup variable in storage.
 *
 * @param key {string} The variable name
 * @returns {*} Empty if the variable is not found.
 * @todo empty should not be associated to not found variable.
 */
Setup.prototype.get = function (key) {
  var _setup = storage.getItem(this.storageKeyName);
  if (_setup == null) {
    _setup = this._setup;
  }
  if (key == undefined) {
    return _setup;
  }
  key = key.split(".");
  var val = jsonQ.pathValue(_setup, key);
  if (val == undefined) {
    return '';
  }
  return val;
};

/**
 * Go to the next setup step in the setup navigation.
 *
 * @param stepId {string} The step identifier
 * @returns {string} The step identifier
 */
Setup.prototype.navigationNext = function (stepId) {
  var currentStepId = this.get('stepId');
  var currentStepsHistory = this.get('stepsHistory');

  // If the same step is requested, we do nothing.
  if (stepId == currentStepId) {
    return stepId;
  }

  var steps = [];

  if (currentStepsHistory != '') {
    steps = currentStepsHistory.split('/');
  }

  if (currentStepId != '') {
    steps.push(currentStepId);
  }

  this.set('stepId', stepId);
  this.set('stepsHistory', steps.join('/'));

  return stepId;
};

/**
 * Go back to previous step in the setup navigation.
 *
 * @returns {string} The previous step identifier
 */
Setup.prototype.navigationBack = function () {

  var currentStepsHistory = this.get('stepsHistory');
  if (currentStepsHistory == '') {
    return '';
  }

  var stepsArr = currentStepsHistory.split('/');
  var lastStep = stepsArr.pop();
  var steps = (stepsArr.length == 0 ? '' : stepsArr.join('/'));

  this.set('stepId', lastStep);
  this.set('stepsHistory', steps);

  return lastStep;
};

/**
 * Get the navigation history.
 *
 * @returns {array}
 */
Setup.prototype.getNavigationHistory = function () {
  var currentStepsHistory = this.get('stepsHistory');
  if (currentStepsHistory == '') {
    return [];
  }
  return currentStepsHistory.split('/');
};

/**
 * Flush storage from setup data.
 */
Setup.prototype.flush = function () {
  storage.removeItem(this.storageKeyName);
};

/**
 * Reset the setup process.
 */
Setup.prototype.reset = function () {
  // Delete user settings
  var user = new User();
  user.settings.flush();

  // Flush the keyring.
  var keyring = new Keyring();
  keyring.flush(Keyring.PUBLIC);
};

/**
 * Save setup data on the server.
 *
 * If server returns a positive response, then
 * proceed with plugin configuration.
 *  - Set user
 *  - Sync public key in keyring
 *  - Set domain and other settings
 *
 * @param data {array} The setup date to save
 * @return {promise}
 */
Setup.prototype.save = function(data) {
  var _this = this,
    _response = {},
    deferred = defer();

  var url = data.settings.domain + '/users/validateAccount/' + data.user.id + '.json';
  var keyring = new Keyring();

  // Build request data.
  var requestData = {
    'AuthenticationToken': {
      'token': data.settings.token
    },
    'Gpgkey': {
      'key' : data.key.publicKeyArmored
    }
  };

  // Save the new password and other information.
  fetch(
    url, {
      method: 'PUT',
      credentials: 'include',
      body: JSON.stringify(requestData),
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      }
    })
    .then(function(response) {
      _response = response;
      return response.json();
    })
    .then(function(json) {
      // Check response status
      if (!_response.ok || typeof json.header == 'undefined'
        || typeof json.header.status == 'undefined' || json.header.status != 'success') {
        return deferred.reject({
          message: 'server response error',
          data: {
            request: requestData,
            response: json
          }
        });
      } else {
        return _this.saveSettings(data);
      }
    })
    .then(
      function success() {
        deferred.resolve();
      },
      function error(error){
        deferred.reject(error);
      }
    )
    .catch(function(error){
      return deferred.reject(error);
    });

  return deferred.promise;
};

/**
 * Complete recovery process.
 * Inform server that the recovery is complete and save the recovered settings.
 *
 * @param data {array} The recovery data
 * @returns {promise}
 */
Setup.prototype.completeRecovery = function(data) {
  var _this = this,
    _response = {},
    deferred = defer();

  var url = data.settings.domain + '/setup/completeRecovery/' + data.user.id + '.json';

  // Build request data.
  var requestData = {
    'AuthenticationToken': {
      'token': data.settings.token
    },
    'Gpgkey': {
      'key' : data.key.publicKeyArmored
    }
  };

  // Save the new password and other information.
  fetch(
    url, {
      method: 'PUT',
      credentials: 'include',
      body: JSON.stringify(requestData),
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      }
    })
    .then(function(response) {
      _response = response;
      return response.json();
    })
    .then(function(json) {
      // Check response status
      if (!_response.ok || typeof json.header == 'undefined'
        || typeof json.header.status == 'undefined' || json.header.status != 'success') {
        return deferred.reject({
          message: 'server response error',
          data: {
            request: requestData,
            response: json
          }
        });
      } else {
        return _this.saveSettings(data);
      }
    })
    .then(
      function success() {
        deferred.resolve();
      },
      function error(error){
        deferred.reject(error);
      }
    )
    .catch(function(error){
      return deferred.reject(error);
    });

  return deferred.promise;
};

/**
 * Save setup data into settings.
 *
 * @param setupData {setupData}
 * @returns {promise}
 */
Setup.prototype.saveSettings = function (setupData) {
  var deferred = defer(),
    keyring = new Keyring(),
    userInfo = null;

  // Save the user settings, e.g. security token & domain
  var user = new User();
  try {
    user.settings.setSecurityToken(setupData.settings.securityToken);
    // Save baseUrl.
    user.settings.setDomain(setupData.settings.domain);
    // Save user.
    userInfo = {
      id: setupData.user.id,
      username: setupData.user.username,
      firstname: setupData.user.firstname,
      lastname: setupData.user.lastname
    };
    user.set(userInfo);

  } catch (e) {
    deferred.reject({
      message: e.message,
      data: {
        token: setupData.settings.securityToken,
        domain: setupData.settings.domain,
        user: userInfo
      }
    });
    return deferred.promise;
  }

  // Flush the public keyring.
  keyring.flush(Keyring.PUBLIC);
  // Flush the private keyring.
  keyring.flush(Keyring.PRIVATE);

  // Import server key into keyring.
  try {
    keyring.importServerPublicKey(setupData.settings.armoredServerKey, setupData.settings.domain);
  }
  catch (e) {
    deferred.reject({
      message: 'error importing the server key : ' + e.message,
      data: {
        serverKey: setupData.settings.armoredServerKey
      }
    });
    return deferred.promise;
  }

  // Import private key into keyring.
  try {
    keyring.importPrivate(setupData.key.privateKeyArmored);
  }
  catch (e) {
    deferred.reject({
      message: 'error importing the private key : ' + e.message,
      data: {
        key: setupData.key.privateKeyArmored,
        userId: setupData.user.id
      }
    });
    return deferred.promise;
  }

  // Store the user public key in the keyring.
  // We store the one generated locally, not the one returned by the server.
  try {
    keyring.importPublic(setupData.key.publicKeyArmored, setupData.user.id);
  } catch (e) {
    deferred.reject({
      message: 'error importing the public key : ' + e.message,
      data: {
        key: setupData.key.publicKeyArmored,
        userId: setupData.user.id
      }
    });
    return deferred.promise;
  }

  // Everything alright, we resolve.
  deferred.resolve();
  return deferred.promise;
};

/**
 * Check if a key exist on the server.
 *
 * The check is based on the verify step of authentication.
 * We have a slightly different function that auth.verify, because at this stage none
 * of the data we are working with are in the keyring.
 *
 * @param userFingerprint {string} The user key finger print
 * @return {promise}
 */
Setup.prototype.checkKeyExistRemotely = function (userFingerprint) {
  var armoredServerKey = this.get('settings.armoredServerKey');
  var serverUrl = this.get('settings.domain');
  var gpgAuth = new Auth();
  return gpgAuth.verify(serverUrl, armoredServerKey, userFingerprint);
};

// Exports the Setup object.
exports.Setup = Setup;

},{"../sdk/core/promise":60,"../sdk/l10n":61,"./auth":29,"./config":30,"./crypto":31,"./keyring":37,"./user":44}],43:[function(require,module,exports){
/**
 * Tab storage model.
 *
 * The aim of the tab storage model is to offer a temporary storage layer to
 * make different parts of the application able to share data.
 *
 * By instance allowing different workers to share data together.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

var _store = {};
exports._store = _store;

/**
 * The TabStorage constructor.
 * @constructor
 */
var TabStorage = function () {};

/**
 * Init the storage for a given tab.
 * When the tab is closed the storage is flushed.
 * @param tab {Tab} The tab to init the storage on
 */
TabStorage.initStorage = function (tab) {
  // Clean the tab storage on close.
  var onTabCloseHandler = function(tab) {
    TabStorage.destroyStorage(tab.id);
  };
  tab.on('close', onTabCloseHandler);
};

/**
 * Clean the stored values for a tabId.
 * @param tabId {string} The tab identifier
 */
TabStorage.destroyStorage = function (tabId) {
  if (_store[tabId]) {
    delete _store[tabId];
  }
};

/**
 * Get a value stored in the tab storage.
 * @param tabId {string} The tab identifier
 * @param key {string} The variable name
 * @returns {*}
 */
TabStorage.get = function (tabId, key) {
  if (_store[tabId] && _store[tabId][key]) {
    return _store[tabId][key];
  }
  return undefined;
};

/**
 * Store a value in the tab storage.
 * @param tabId {string} The tab identifier
 * @param key {string} The variable name
 * @param value {*} The variable value
 */
TabStorage.set = function (tabId, key, value) {
  if (!_store[tabId]) {
    _store[tabId] = {};
  }
  _store[tabId][key] = value;
};

/**
 * Delete a value from the tab storage.
 * @param tabId {string} The tab identifier
 * @param key {string} The variable name
 */
TabStorage.remove = function (tabId, key) {
  if (_store[tabId][key]) {
    delete _store[tabId][key];
  }
};

exports.TabStorage = TabStorage;

},{}],44:[function(require,module,exports){
/**
 * User model.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var Config = require('./config');
var Settings = require('./settings').Settings;

// var Validator = require('../vendors/validator');
// var fetch = require('../vendors/window').fetch;
// const { htmlspecialchars, in_array } = require('../vendors/phpjs');

const { defer } = require('../sdk/core/promise');
var { setTimeout } = require('../sdk/timers');
var __ = require('../sdk/l10n').get;

// Will store temporarily the user master password if the user wants the
// system to remember it.
// Will be a json object with :
// - password: value of master password
// - created: timestamp when it was storeds
var _masterPassword = null;

/**
 * The class that deals with users.
 */
var User = function () {

  // see model/settings
  this.settings = new Settings();

  // reference to the user object returned by the server
  this._remote_user = {};

  // the fields
  this._user = {};

  // URLs
  this.URL_GET_REMOTE = '/users/me.json';
};

/**
 * Validate user fields individually
 *
 * @param field {string} The name of the field to validate
 * @param value {string} The value of the field to validate
 * @returns {boolean}
 * @throw Error if the field is not valid
 * @private
 */
User.prototype.__validate = function (field, value) {
  switch (field) {
    case 'firstname':
      if (typeof value === 'undefined' || value === '') {
        throw new Error(__('The first name cannot be empty'));
      }
      if (!Validator.isAlphanumericSpecial(value)) {
        throw new Error(__('The first name should only contain alphabetical and numeric characters'))
      }
      break;
    case 'lastname' :
      if (typeof value === 'undefined' || value === '') {
        throw new Error(__('The last name cannot be empty'));
      }
      if (!Validator.isAlphanumericSpecial(value)) {
        throw new Error(__('The last name should only contain alphabetical and numeric characters'))
      }
      break;
    case 'username' :
      if (typeof value === 'undefined' || value === '') {
        throw new Error(__('The username cannot be empty'));
      }
      if (!Validator.isEmail(value)) {
        throw new Error(__('The username should be a valid email address'))
      }
      break;
    case 'id' :
      if (typeof value === 'undefined' || value === '') {
        throw new Error(__('The user id cannot be empty'));
      }
      if (!Validator.isUUID(value)) {
        throw new Error(__('The user id should be a valid UUID'))
      }
      break;
    default :
      throw new Error(__('No validation defined for field: ' + field));
      break;
  }
  return true;
};

/**
 * Validate a user
 *
 * @param user {object} The user to validate
 * @param fields {array} The names of the fields to validate
 * @returns {object} The user in case of success
 * @throw Error if the user is not valid
 */
User.prototype.validate = function (user, fields) {
  if (fields == undefined) {
    fields = ['id', 'username', 'firstname', 'lastname'];
  }

  var errors = [];
  for (var i in fields) {
    var fieldName = fields[i];
    try {
      this.__validate(fieldName, user[fieldName]);
    } catch (e) {
      var fieldError = {};
      fieldError[fieldName] = e.message;
      errors.push(fieldError);
    }
  }

  if (errors.length > 0) {
    // Return exception with details in validationErrors.
    var e = new Error(__('user could not be validated'));
    // Add validation errors to the error object.
    e.validationErrors = errors;
    throw e;
  }

  return user;
};

/**
 * Set a firstname and last name for the plugin user
 *
 * @param firstname {string} The user first name
 * @param lastname {string} The user last name
 * @return {bool}
 * @throw Error if the firsname or the lastname are not valid
 */
User.prototype.setName = function (firstname, lastname) {
  this.__validate('firstname', firstname);
  this.__validate('lastname', lastname);
  this._user.lastname = lastname;
  this._user.firstname = firstname;
  return (Config.write('user.firstname', firstname)
  && Config.write('user.lastname', lastname));
};

/**
 * Set a username for the plugin user
 *
 * @param username {string} The user username
 * @return {bool}
 * @throw Error if the username is not valid
 */
User.prototype.setUsername = function (username) {
  this.__validate('username', username);
  this._user.username = username;
  return (Config.write('user.username', username));
};

/**
 * Set the user id
 *
 * @param id {string} The user id
 * @return {bool}
 * @throw Error if the user id is not valid
 */
User.prototype.setId = function (id) {
  this.__validate('id', id);
  this._user.id = id;
  return (Config.write('user.id', id));
};

/**
 * Set the user
 *
 * @param user {object} The user to set
 * @return {object} The user
 * @throw Error if the user information are not valid
 */
User.prototype.set = function (user) {
  if (typeof user === 'undefined') {
    throw new Error(__('The user cannot be empty'));
  }
  this.setId(user.id);
  this.setUsername(user.username);
  this.setName(user.firstname, user.lastname);

  if (typeof user.settings !== 'undefined') {
    this.settings.set(user.settings);
  }

  return this._user;
};

/**
 * Get the user and validate values before returning them
 *
 * @param fields {array} The fields to retrieve
 *   Example format :
 *   {
 *     user : ['firstname', 'lastname', 'username'],
 *     settings : ['domain', 'securityToken']
 *   }
 *
 *   Not providing this parameter will result in the function
 *   returning all the data known.
 * @return {object}
 * @throw Error if the user or the setting are not valid
 */
User.prototype.get = function (data) {
  try {

    if (data != undefined && data.user != undefined) {
      this._getLocal(data.user);
    }
    else {
      this._getLocal();
    }
    var user = this._user;

    // Get settings according to data provided.
    if (data != undefined && data.user != undefined && data.settings != undefined) {
      user.settings = this.settings.get(data.settings);
    }
    // If no data is provided, get everything.
    else if (data == undefined) {
      user.settings = this.settings.get();
    }

    return user;

  } catch (e) {
    throw new Error(__('The user is not set'));
  }
};

/**
 * Get the user name
 *
 * @return {object}
 * format :
 *   {
 *     firstname : 'FIRST_NAME',
 *     lastname : 'LAST_NAME'
 *   }
 */
User.prototype.getName = function () {
  var name = {
    firstname: Config.read('user.firstname'),
    lastname: Config.read('user.lastname')
  };
  return name;
};

/**
 * Get the username
 *
 * @return {string}
 */
User.prototype.getUsername = function () {
  return Config.read('user.username');
};

/**
 * Get the current user from the local storage.
 * All data returned are validated once again.
 *
 * @param fields {array} The fields names to retrieve.
 * @return {object}
 * @throw Exception in case a data doesn't validate before being returned
 */
User.prototype._getLocal = function (fields) {
  // Default data to return for user.
  var userDefaultFields = [
    "id",
    "username",
    "firstname",
    "lastname"
  ];

  // If data is not provided as a parameter, we use default data.
  if (fields == undefined) {
    fields = userDefaultFields;
  }

  // For each user data requested, try to retrieve it and validate it.
  for (var i in fields) {
    var varName = fields[i];
    this._user[varName] = Config.read('user.' + varName);

    try {
      this.__validate(varName, this._user[varName]);
    } catch (e) {
      this._user[varName] = {};
      throw new Error(__('The user is not set'));
    }
  }

  return this._user;
};

/**
 * Get the user logged-in on the server
 *
 * @returns {promise}
 */
User.prototype._getRemote = function () {
  var deferred = defer(),
    self = this,
    url;

  //Check if there is a trusted domain
  try {
    url = self.settings.getDomain() + this.URL_GET_REMOTE;
  } catch (e) {
    deferred.reject(__('The application domain is not set'));
  }

  // Try to get the current user from memory cache
  if (typeof this._remote_user !== 'undefined') {
    return deferred.resolve(this._remote_user);
  }

  // If it's not done already, get it from remote server
  fetch(
    url, {
      method: 'GET',
      credentials: 'include',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      }
    })
    .then(function (response) {
      _response = response;
      return response.json();
    })
    .then(function (json) {
      // Check response status
      if (!_response.ok) {
        var msg = __('Could not get the current user information. The server responded with an error.');
        if (json.headers.msg != undefined) {
          msg += ' ' + json.headers.msg;
        }
        msg += ' (' + _response.status + ')';
        return deferred.reject(new Error(msg));
      }
      // Save temporarily and return remote version of current user
      self._remote_user = json.body;
      return deferred.resolve(json.body);
    })
    .catch(function (error) {
      return deferred.reject(error);
    });

  return deferred.promise;
};

/**
 * Check if the current user and its settings are valid
 *
 * @returns {boolean}
 */
User.prototype.isValid = function () {
  // @TODO check if local and remote matches
  try {
    this.get();
  } catch (e) {
    return false;
  }
  return this.settings.isValid();
};

/**
 * Check if the current user is logged-in
 *
 * @returns {promise}
 */
User.prototype.isLoggedIn = function () {
  var deferred = defer();

  fetch(
    this.settings.getDomain() + '/auth/checkSession.json', {
      method: 'GET',
      credentials: 'include',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      }
    })
    .then(function (response) {
      _response = response;
      return response.json();
    })
    .then(function (json) {
      // Check response status
      if (!_response.ok) {
        return deferred.reject(new Error(__('The user is not logged-in')));
      }
      deferred.resolve(__('The user is logged-in'));
    })
    .catch(function (error) {
      return deferred.reject(error);
    });

  return deferred.promise;
};

/**
 * Store master password temporarily.
 *
 * @param masterPassword {string} The master password to store.
 */
User.prototype.storeMasterPasswordTemporarily = function (masterPassword) {
  _masterPassword = {
    "password": masterPassword,
    "created": Math.round(new Date().getTime() / 1000.0)
  };
  var timeout = 5 * 60; // 5 minutes.
  this._loopDeleteMasterPasswordOnTimeout(timeout);
};

/**
 * Loop to be executed every second to check if the master password should be deleted.
 *
 * @param timeout {int} timeout in seconds (example, if password should be
 *  deleted after 5 minutes, 5*60)
 * @private
 */
User.prototype._loopDeleteMasterPasswordOnTimeout = function (timeout) {
  var self = this;
  var currentTimestamp = Math.round(new Date().getTime() / 1000.0);
  if (currentTimestamp >= _masterPassword.created + timeout) {
    _masterPassword = null;
  }
  else {
    setTimeout(function () {
      self._loopDeleteMasterPasswordOnTimeout(timeout);
    }, 1000);
  }
};

/**
 * Retrieve master password from memory, in case it was stored temporarily
 * by the user.
 * @returns {promise}
 */
User.prototype.getStoredMasterPassword = function () {
  var deferred = defer();
  if (_masterPassword !== null) {
    deferred.resolve(_masterPassword.password);
  }
  else {
    deferred.reject();
  }

  return deferred.promise;
};


User.prototype.searchUsers = function(keywords, excludedUsers) {
  var deferred = defer();

  fetch(
      this.settings.getDomain() + '/users.json?filter[keywords]=' + htmlspecialchars(keywords, 'ENT_QUOTES') + '&filter[is-active]=1', {
        method: 'GET',
        credentials: 'include',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        }
      })
      .then(function (response) {
        _response = response;
        return response.json();
      })
      .then(function (json) {
        // Check response status
        if(!_response.ok) {
          var msg = __('Could not get the users. The server responded with an error.');
          if(json.headers.msg != undefined) {
            msg += ' ' + json.headers.msg;
          }
          msg += ' (' + _response.status + ')';
          return deferred.reject(new Error(msg));
        }
        var users = json.body;
        var finalUsers = [];
        for (var i in users) {
          if (!in_array(users[i].User.id, excludedUsers)) {
            finalUsers.push(users[i]);
          }
        }

        return deferred.resolve(finalUsers);
      })
      .catch(function (error) {
        return deferred.reject(error);
      });

  return deferred.promise;
};

// Exports the User object.
exports.User = User;
},{"../sdk/core/promise":60,"../sdk/l10n":61,"../sdk/timers":67,"./config":30,"./settings":41}],45:[function(require,module,exports){
/**
 * The aim of the worker model is to manage instantiated workers.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var app = require('../app');

/**
 * Reference a worker.
 * @param workerId {string} The worker identifier
 * @param worker {Worker} The worker to reference
 * @param options {array} Optional data
 */
var add = function (workerId, worker, options) {
  options = options || {};
  var url = worker.tab.url;

  if (exists(workerId, worker.tab.id)) {
    // if a worker with same id is already in the tab
    // // destroy it, it will trigger a detach event (see bellow)
    app.workers[worker.tab.id][workerId].destroy('destroying worker because it already exist');
  }
  
  // Add the worker to the list of active app workers.
  // Build the workers list for that tab if needed
  console.debug('Add worker @ id:' + workerId + ', tab:' + worker.tab.id + ', url:' + worker.tab.url);
  if (typeof app.workers[worker.tab.id] === 'undefined') {
    app.workers[worker.tab.id] = {};
  }
  app.workers[worker.tab.id][workerId] = worker;

  // Listen to tab url changes.
  // If callback given in option on url change, call it
  // var onTabReadyHandler = function (tab) {
  //   if (url != tab.url.split('#')[0]) {
  //     // console.log('url changed on tabReadyHandler');
  //     if (options.onTabUrlChange) {
  //       options.onTabUrlChange(worker);
  //     }
  //     worker.tab.removeListener('ready', onTabReadyHandler);
  //   }
  // };
  // worker.tab.on('ready', onTabReadyHandler);

  // Listen to worker detach event
  // This event is called as part of the worker destroy
  // Remove the worker from the list
  var onWorkerDetachHandler = function () {
    remove(workerId, worker.tab.id, options);
  };
  worker.on('detach', onWorkerDetachHandler);

};
exports.add = add;

/**
 * Unreference a worker.
 * @param tabId {string} The tab identifier on which the worker runs
 * @param workerId {string} The worker identifier
 * @param options {array} Optional parameters
 *  - options.onDestroy {function} Callback to execute when the worker is
 *    destroyed.
 */
var remove = function (workerId, tabId, options) {
  if (!exists(workerId, tabId)) {
    console.warn('Warning: unable to remove the worker ' + workerId + ', it doesn\'t exist on the tab ' + tabId + ' .');
  } else {
    console.debug('Remove worker @ id:' + workerId + ', tab:' + tabId);
    if (typeof options.onDestroy !== 'undefined') {
      options.onDestroy();
    }
    delete app.workers[tabId][workerId];
  }
};

/**
 * Get a worker.
 * @param workerId {string} The worker identifier
 * @param tabId {string} The tab identifier on which the worker runs
 * @return {Worker} null if the worker doesn't exist.
 */
var get = function (workerId, tabId) {
  if (app.workers[tabId][workerId]) {
    return app.workers[tabId][workerId];
  }
  return null;
};
exports.get = get;

/**
 * Get all workers identifiers instantiated on a tab.
 * @param tabId {string} The tab identifier
 * @return {array}
 */
var getAllKeys = function (tabId) {
  return Object.keys(app.workers[tabId]);
};
exports.getAllKeys = getAllKeys;

/**
 * Checks that a worker exists.
 * @param workerId {string} The worker identifier
 * @param tabId {string} The tab identifier on which the worker runs
 * @return {boolean}
 */
var exists = function (workerId, tabId) {
  // if tab does not exist
  if (typeof app.workers[tabId] === 'undefined') {
    return false;
  }
  if (typeof app.workers[tabId][workerId] === 'undefined') {
    return false;
  }
  return true;
};
exports.exists = exists;

},{"../app":1}],46:[function(require,module,exports){
/**
 * Bootstrap pagemod.
 *
 * This pagemod allow inserting classes to help any page
 * to know about the status of the extension, in a modernizr fashion
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var app = require('../app');
var pageMod = require('../sdk/page-mod');
var Worker = require('../model/worker');

var Bootstrap = function () {};
Bootstrap._pageMod = undefined;

Bootstrap.init = function () {

  if (typeof Bootstrap._pageMod !== 'undefined') {
    Bootstrap._pageMod.destroy();
    Bootstrap._pageMod = undefined;
  }

  Bootstrap._pageMod = pageMod.PageMod({
    name: 'Bootstrap',
    include: new RegExp('.*'),
    contentScriptWhen: 'ready',
    contentStyleFile: [],
    contentScriptFile: [
      'data/vendors/jquery.min.js',
      'data/vendors/ejs_production.js',
      'data/js/lib/request.js',
      'data/js/lib/message.js',
      'data/js/lib/html.js',
      'data/js/bootstrap.js'
    ],
    onAttach: function (worker) {
      Worker.add('Bootstrap', worker);
      app.events.template.listen(worker);
      app.events.config.listen(worker);
    }
  });
};
exports.Bootstrap = Bootstrap;

},{"../app":1,"../model/worker":45,"../sdk/page-mod":62}],47:[function(require,module,exports){
/**
 * Debug pagemod.
 *
 * This page mod drives a convenience config page for debug
 * This allows to not have to go through the setup process steps
 * and perform changes useful for testing that would otherwise break things
 * Like for example changing the public key only on the client but not the server
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var pageMod = require('../sdk/page-mod');
var app = require('../app');
var Worker = require('../model/worker');

var Debug = function () {};
Debug._pageMod = undefined;

Debug.init = function () {

  console.warn('Warning: plugin debug mode is on!');
  console.warn(chrome.runtime.getURL('data/config-debug.html'));

  if (typeof Debug._pageMod !== 'undefined') {
    Debug._pageMod.destroy();
    Debug._pageMod = undefined;
  }
  Debug._pageMod = pageMod.PageMod({
    name: 'debug',
    include: chrome.runtime.getURL('data/config-debug.html'),

    contentScriptWhen: 'end',
    contentScriptFile: [
			// Warning: modify the page scripts and styles in
			// chrome/data/config-debug.html and chrome/data/js/load/config-debug.js
    ],
    onAttach: function (worker) {
      Worker.add('debug', worker);
      app.events.config.listen(worker);
      app.events.file.listen(worker);
      app.events.keyring.listen(worker);
      app.events.template.listen(worker);
      app.events.user.listen(worker);
      app.events.debug.listen(worker);
    }
  });
};
exports.Debug = Debug;

},{"../app":1,"../model/worker":45,"../sdk/page-mod":62}],48:[function(require,module,exports){
/**
 * Edit group autocomplete dialog pagemod.
 *
 * This pagemod drives the iframe used when the user adds users to a group
 * and he is looking for new users to add.
 *
 * This pagemod works jointly with the editGroup Pagemod.
 *
 * @copyright (c) 2017-present Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 *
 */
var app = require('../app');
var pageMod = require('../sdk/page-mod');
var Worker = require('../model/worker');

var GroupEditAutocompleteDialog = function () {};
GroupEditAutocompleteDialog._pageMod = undefined;

GroupEditAutocompleteDialog.init = function () {

    if (typeof GroupEditAutocompleteDialog._pageMod !== 'undefined') {
        GroupEditAutocompleteDialog._pageMod.destroy();
        GroupEditAutocompleteDialog._pageMod = undefined;
    }

    GroupEditAutocompleteDialog._pageMod = pageMod.PageMod({
        name: 'GroupEditAutocomplete',
        include: 'about:blank?passbolt=passbolt-iframe-group-edit-autocomplete',

        contentScriptFile: [
					// Warning: Iframe script and styles need to be modified in
					// chrome/data/passbolt-iframe-group-edit-autocomplete.html
        ],
        contentScriptWhen: 'ready',
        onAttach: function (worker) {
            Worker.add('GroupEditAutocomplete', worker);
            app.events.config.listen(worker);
            app.events.passboltPage.listen(worker);
            app.events.group.listen(worker);
            app.events.groupAutocomplete.listen(worker);
            app.events.template.listen(worker);
        }
    });
}
exports.GroupEditAutocompleteDialog = GroupEditAutocompleteDialog;

},{"../app":1,"../model/worker":45,"../sdk/page-mod":62}],49:[function(require,module,exports){
/**
 * EditGroup dialog pagemod.
 *
 * This pagemod drives the iframe used when the user shares a password.
 * It is used when sharing a new password.
 *
 * @copyright (c) 2017-present Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var app = require('../app');
var pageMod = require('../sdk/page-mod');
var Worker = require('../model/worker');
var TabStorage = require('../model/tabStorage').TabStorage;

var GroupEditDialog = function () {};
GroupEditDialog._pageMod = undefined;

GroupEditDialog.init = function () {

    if (typeof GroupEditDialog._pageMod !== 'undefined') {
        GroupEditDialog._pageMod.destroy();
        GroupEditDialog._pageMod = undefined;
    }

    GroupEditDialog._pageMod = pageMod.PageMod({
        name: 'GroupEdit',
        include: 'about:blank?passbolt=passbolt-iframe-group-edit',
        contentScriptFile: [
					// Warning: script and styles need to be modified in
					// chrome/data/passbolt-iframe-password-share.html
        ],
        contentScriptWhen: 'ready',
        onAttach: function (worker) {
            Worker.add('GroupEdit', worker, {
                onDestroy: function () {
                    TabStorage.remove(worker.tab.id, 'groupId');
                    TabStorage.remove(worker.tab.id, 'groupUsers');
                }
            });

            app.events.config.listen(worker);
            app.events.editPassword.listen(worker);
            app.events.passboltPage.listen(worker);
            app.events.secret.listen(worker);
            app.events.group.listen(worker);
            app.events.user.listen(worker);
            app.events.template.listen(worker);
        }
    });
};
exports.GroupEditDialog = GroupEditDialog;

},{"../app":1,"../model/tabStorage":43,"../model/worker":45,"../sdk/page-mod":62}],50:[function(require,module,exports){
/**
 * Master password dialog pagemod.
 *
 * This pagemod drives the dialog/iframe where the user enters the secret key passphrase,
 * also called master password. It is used when encrypting, decrypting, signing, etc.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var app = require('../app');
var pageMod = require('../sdk/page-mod');
var Worker = require('../model/worker');
var TabStorage = require('../model/tabStorage').TabStorage;

var MasterPasswordDialog = function () {};
MasterPasswordDialog._pageMod = undefined;

MasterPasswordDialog.init = function () {

  if (typeof MasterPasswordDialog._pageMod !== 'undefined') {
    MasterPasswordDialog._pageMod.destroy();
    MasterPasswordDialog._pageMod = undefined;
  }

  MasterPasswordDialog._pageMod = pageMod.PageMod({
    name: 'MasterPassword',
    include: 'about:blank?passbolt=passbolt-iframe-master-password',
    contentScriptFile: [
			// Warning: script and styles need to be modified in
			// src/chrome/data/passbolt-iframe-master-password.html
    ],
    contentScriptWhen: 'ready',
    onAttach: function (worker) {
      Worker.add('MasterPassword', worker, {
        // on destroy, clean.
        onDestroy: function() {
          TabStorage.remove(worker.tab.id, 'masterPasswordRequest');
        }
      });
      app.events.config.listen(worker);
      app.events.masterPasswordIframe.listen(worker);
      app.events.masterPassword.listen(worker);
      app.events.template.listen(worker);
      app.events.passboltPage.listen(worker);
      app.events.user.listen(worker);
    }
  });
};
exports.MasterPasswordDialog = MasterPasswordDialog;

},{"../app":1,"../model/tabStorage":43,"../model/worker":45,"../sdk/page-mod":62}],51:[function(require,module,exports){
/**
 * Passbolt App pagemod.
 *
 * This pagemod drives the main addon app
 * It is inserted in all the pages of a domain that is trusted.
 * Such trust is defined during the first step of the setup process (or in config-debug)
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var app = require('../app');
var pageMod = require('../sdk/page-mod');
var Worker = require('../model/worker');
var user = new (require('../model/user').User)();
var TabStorage = require('../model/tabStorage').TabStorage;

var PassboltApp = function () {
};
PassboltApp._pageMod = null;

PassboltApp.exists = function () {
  return PassboltApp._pageMod !== null;
};

PassboltApp.destroy = function () {
  if (PassboltApp.exists()) {
    PassboltApp._pageMod.destroy();
    PassboltApp._pageMod = null;
  }
};

PassboltApp.initPageMod = function () {
  // Attach on passbolt application pages.
  // By instance if your application domain is : https://demo.passbolt.com
  // The pagemod will be attached to the following pages :
  //  https://demo.passbolt.com
  //  https://demo.passbolt.com/
  //  https://demo.passbolt.com/#user
  //  https://demo.passbolt.com/#workspace
  //  https://demo.passbolt.com.attacker.com
  //  https://demo.passbolt.com/auth/login
  var url = '^' + user.settings.getDomain() + '/?(#.*)?$';
  var regex = new RegExp(url);
  return pageMod.PageMod({
    name: 'PassboltApp',
    include: regex,
    contentScriptWhen: 'ready',
    contentStyleFile: [
      'data/css/external.min.css'
    ],
    contentScriptFile: [
      'data/vendors/jquery.min.js',
      'data/vendors/ejs_production.js',
      'data/js/lib/message.js',
      'data/js/lib/request.js',
      'data/js/lib/html.js',
      'data/js/lib/clipboard.js',
      'data/js/masterPassword/iframe.js',
      'data/js/secret/editIframe.js',
      'data/js/secret/shareIframe.js',
      'data/js/group/editIframe.js',
      'data/js/progress/iframe.js',
      'data/js/app.js'
    ],
    attachTo: ["existing", "top"],
    onAttach: function (worker) {
      TabStorage.initStorage(worker.tab);

      Worker.add('App', worker
      // {
      //   // FIREFOX ONLY -
      //   // If the user is redirected to the login page, that means it is logged out.
      //   // Destroy the passbolt application pagemod.
      //   // Chrome workers are always destroyed on URL change
      //   onTabUrlChange: function () {
      //     if (worker.tab.url === (user.settings.getDomain() + '/auth/login')) {
      //       PassboltApp.destroy();
      //     }
      //   }
      // }
      );

      app.events.clipboard.listen(worker);
      app.events.config.listen(worker);
      app.events.editPassword.listen(worker);
      app.events.keyring.listen(worker);
      app.events.secret.listen(worker);
      app.events.template.listen(worker);
      app.events.group.listen(worker);
      app.events.masterPasswordIframe.listen(worker);
      app.events.app.listen(worker);
    }
  });
};

PassboltApp.init = function () {
  // According to the user status :
  // * the pagemod should be initialized if the user is valid and logged in;
  // * the pagemod should be destroyed otherwise;
  if (user.isValid()) {
    user.isLoggedIn().then(
      // If it is already logged-in.
      function success() {
        PassboltApp.destroy();
        PassboltApp._pageMod = PassboltApp.initPageMod();
      },
      // If it is logged-out.
      function error() {
        PassboltApp.destroy();
      }
    );
  }
};

exports.PassboltApp = PassboltApp;
},{"../app":1,"../model/tabStorage":43,"../model/user":44,"../model/worker":45,"../sdk/page-mod":62}],52:[function(require,module,exports){
/**
 * Passbolt Auth Form pagemod.
 *
 * This pagemod help with the authentication
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var pageMod = require('../sdk/page-mod');
var app = require('../app');
var Worker = require('../model/worker');

var PassboltAuthForm = function () {};
PassboltAuthForm._pageMod = undefined;

PassboltAuthForm.init = function () {

  if (typeof PassboltAuthForm._pageMod !== 'undefined') {
    PassboltAuthForm._pageMod.destroy();
    PassboltAuthForm._pageMod = undefined;
  }
  PassboltAuthForm._pageMod = pageMod.PageMod({
    name: 'AuthForm',
    include: 'about:blank?passbolt=passbolt-iframe-login-form',
    contentScriptWhen: 'ready',
    contentScriptFile: [
			// Warning: script and styles need to be modified in
			// chrome/data/passbolt-iframe-login-form.html
    ],
    onAttach: function (worker) {
      Worker.add('AuthForm', worker);
      app.events.template.listen(worker);
      app.events.user.listen(worker);
      app.events.keyring.listen(worker);
      app.events.auth.listen(worker);
    }
  });
};
exports.PassboltAuthForm = PassboltAuthForm;

},{"../app":1,"../model/worker":45,"../sdk/page-mod":62}],53:[function(require,module,exports){
/**
 * Passbolt Auth pagemod.
 *
 * This pagemod help with the authentication
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var app = require('../app');
var user = new (require('../model/user').User)();
var pageMod = require('../sdk/page-mod');
var Worker = require('../model/worker');

var PassboltAuth = function () {};
PassboltAuth._pageMod = undefined;

PassboltAuth.init = function () {

  if (typeof PassboltAuth._pageMod !== 'undefined') {
    PassboltAuth._pageMod.destroy();
    PassboltAuth._pageMod = undefined;
  }

  // The pagemod will be attached to the following pages:
  //  https://demo.passbolt.com/auth/login
  //  https://demo.passbolt.com/auth/login/
  //  https://demo.passbolt.com/auth/login#checkthis
  //  https://demo.passbolt.com/auth/login/nope
  var url = '^' + user.settings.getDomain() + '/auth/login/?(#.*)?$';
  var domain = new RegExp(url);

  PassboltAuth._pageMod = pageMod.PageMod({
    name: 'Auth',
    include: domain,
    contentScriptWhen: 'ready',
    contentStyleFile: [
      'data/css/external.min.css'
    ],
    contentScriptFile: [
      'data/vendors/jquery.min.js',
      'data/vendors/ejs_production.js',
      'data/js/lib/message.js',
      'data/js/lib/request.js',
      'data/js/lib/html.js',
      'data/js/login/login.js'
    ],
    attachTo: ["existing", "top"],
    onAttach: function (worker) {
      Worker.add('Auth', worker);
      app.events.config.listen(worker);
      app.events.template.listen(worker);
      app.events.keyring.listen(worker);
      app.events.secret.listen(worker);
      app.events.user.listen(worker);
      app.events.auth.listen(worker);
    }
  });
};
exports.PassboltAuth = PassboltAuth;

},{"../app":1,"../model/user":44,"../model/worker":45,"../sdk/page-mod":62}],54:[function(require,module,exports){
/**
 * Progress dialog pagemod.
 *
 * This pagemod drives the progress bar iframe
 * It is used when the add-on is encrypting something
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var app = require('../app');
var pageMod = require('../sdk/page-mod');
var Worker = require('../model/worker');

var ProgressDialog = function () {};
ProgressDialog._pageMod = undefined;

ProgressDialog.init = function () {

  if (typeof ProgressDialog._pageMod !== 'undefined') {
    ProgressDialog._pageMod.destroy();
    ProgressDialog._pageMod = undefined;
  }

  ProgressDialog._pageMod = pageMod.PageMod({
    name: 'Progress',
    include: 'about:blank?passbolt=passbolt-iframe-progress-dialog*',

    contentScriptFile: [
			// Warning: script and styles need to be modified in
			// chrome/data/passbolt-iframe-progress-dialog.html
    ],
    contentScriptWhen: 'ready',
    onAttach: function (worker) {
      Worker.add('Progress', worker);
      app.events.template.listen(worker);
    }
  });
};
exports.ProgressDialog = ProgressDialog;
},{"../app":1,"../model/worker":45,"../sdk/page-mod":62}],55:[function(require,module,exports){
/**
 * Decrypt dialog pagemod.
 *
 * This pagemod drives the iframe used when the user enter a password to be stored by passbolt
 * It is used when creating/editing a new password
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 *
 */
var app = require('../app');
var pageMod = require('../sdk/page-mod');
var Worker = require('../model/worker');
var TabStorage = require('../model/tabStorage').TabStorage;

var SecretEditDialog = function () {};
SecretEditDialog._pageMod = undefined;

SecretEditDialog.init = function () {

  if (typeof SecretEditDialog._pageMod !== 'undefined') {
    SecretEditDialog._pageMod.destroy();
    SecretEditDialog._pageMod = undefined;
  }

  SecretEditDialog._pageMod = pageMod.PageMod({
    name: 'Secret',
    include: 'about:blank?passbolt=passbolt-iframe-secret-edition*',
    contentScriptFile: [
			// Warning: script and styles need to be modified in
			// chrome/data/passbolt-iframe-secret-edition.html
    ],
    contentScriptWhen: 'ready',
    onAttach: function (worker) {
      app.events.config.listen(worker);
      app.events.editPassword.listen(worker);
      app.events.passboltPage.listen(worker);
      app.events.secret.listen(worker);
      app.events.template.listen(worker);
      app.events.user.listen(worker);

      Worker.add('Secret', worker, {
        // on destroy, clean.
        onDestroy: function () {
          TabStorage.remove(worker.tab.id, 'editedPassword');
        }
      });
    }
  });
};
exports.SecretEditDialog = SecretEditDialog;

},{"../app":1,"../model/tabStorage":43,"../model/worker":45,"../sdk/page-mod":62}],56:[function(require,module,exports){
/**
 * Setup bootstrap pagemod.
 *
 * This pagemod help bootstrap the first step of the setup process from a passbolt server app page
 * The pattern for this url, driving the setup bootstrap, is defined in config.json
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var app = require('../app');
var pageMod = require('../sdk/page-mod');
var Worker = require('../model/worker');

var uuidRegex = "([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[0-5][a-fA-F0-9]{3}-[089aAbB][a-fA-F0-9]{3}-[a-fA-F0-9]{12})";
var setupBootstrapRegex = "(.*)\/setup\/(install|recover)\/" + uuidRegex + "\/" + uuidRegex;

var SetupBootstrap = function () {
};
SetupBootstrap._pageMod = undefined;

SetupBootstrap.init = function () {
  if (typeof SetupBootstrap._pageMod !== 'undefined') {
    SetupBootstrap._pageMod.destroy();
    SetupBootstrap._pageMod = undefined;
  }

  SetupBootstrap._pageMod = pageMod.PageMod({
    name: 'SetupBootstrap',
    include: new RegExp(setupBootstrapRegex),
    contentScriptWhen: 'ready',
    contentStyleFile: [],
    contentScriptFile: [
			'data/vendors/jquery.min.js',
      'data/js/lib/message.js',
      'data/js/lib/request.js',
      'data/js/setup/bootstrap.js'
    ],
    onAttach: function (worker) {
      Worker.add('SetupBootstrap', worker);
      app.events.config.listen(worker);
      app.events.setupbootstrap.listen(worker);
    }
  });
};

exports.SetupBootstrap = SetupBootstrap;
},{"../app":1,"../model/worker":45,"../sdk/page-mod":62}],57:[function(require,module,exports){
/**
 * Setup pagemod.
 *
 * This page mod drives the reset of setup process
 * The reset of the setup process is driven on the add-on side, see in ../data/ setup.html and js/setup.js
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var pageMod = require('../sdk/page-mod');

var app = require('../app');
var Worker = require('../model/worker');

/*
 * This pagemod help bootstrap the first step of the setup process from a passbolt server app page
 * The pattern for this url, driving the setup bootstrap, is defined in config.json
 */
var Setup = function () {};
Setup._pageMod = undefined;

Setup.init = function () {

  if (typeof Setup._pageMod !== 'undefined') {
    Setup._pageMod.destroy();
    Setup._pageMod = undefined;
  }

  Setup._pageMod = pageMod.PageMod({
    name: 'Setup',
    include: chrome.runtime.getURL('setup.html'),
    contentScriptWhen: 'end',
    contentScriptFile: [
			// Warning: script and styles need to be modified in
			// chrome/data/setup.html and chrome/data/js/load/setup.js
		],
    onAttach: function (worker) {
      app.events.template.listen(worker);
      app.events.clipboard.listen(worker);
      app.events.setup.listen(worker);
      app.events.file.listen(worker);
      app.events.keyring.listen(worker);
      app.events.auth.listen(worker);
      app.events.user.listen(worker);
      app.events.config.listen(worker);

      Worker.add('Setup', worker);
    }
  });
};

exports.Setup = Setup;

},{"../app":1,"../model/worker":45,"../sdk/page-mod":62}],58:[function(require,module,exports){
/**
 * Share autocomplete dialog pagemod.
 *
 * This pagemod drives the iframe used when the user shares a password
 * and he is looking for new users to grant.
 *
 * This pagemod works jointly with the shareDialog Pagemod.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 *
 */
var app = require('../app');
var pageMod = require('../sdk/page-mod');
var Worker = require('../model/worker');

var ShareAutocompleteDialog = function () {};
ShareAutocompleteDialog._pageMod = undefined;

ShareAutocompleteDialog.init = function () {

  if (typeof ShareAutocompleteDialog._pageMod !== 'undefined') {
    ShareAutocompleteDialog._pageMod.destroy();
    ShareAutocompleteDialog._pageMod = undefined;
  }

  ShareAutocompleteDialog._pageMod = pageMod.PageMod({
    name: 'ShareAutocomplete',
    include: 'about:blank?passbolt=passbolt-iframe-password-share-autocomplete',
    contentScriptFile: [
			// Warning: script and styles need to be modified in
			// chrome/data/passbolt-iframe-password-share-autocomplete.html
    ],
    contentScriptWhen: 'ready',
    onAttach: function (worker) {
      Worker.add('ShareAutocomplete', worker);
      app.events.config.listen(worker);
      app.events.passboltPage.listen(worker);
      app.events.shareAutocomplete.listen(worker);
      app.events.template.listen(worker);
    }
  });
};
exports.ShareAutocompleteDialog = ShareAutocompleteDialog;

},{"../app":1,"../model/worker":45,"../sdk/page-mod":62}],59:[function(require,module,exports){
/**
 * Share dialog pagemod.
 *
 * This pagemod drives the iframe used when the user shares a password.
 * It is used when sharing a new password.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var app = require('../app');
var pageMod = require('../sdk/page-mod');
var Worker = require('../model/worker');
var TabStorage = require('../model/tabStorage').TabStorage;

var ShareDialog = function () {};
ShareDialog._pageMod = undefined;

ShareDialog.init = function () {

  if (typeof ShareDialog._pageMod !== 'undefined') {
    ShareDialog._pageMod.destroy();
    ShareDialog._pageMod = undefined;
  }

  ShareDialog._pageMod = pageMod.PageMod({
    name: 'Share',
    include: 'about:blank?passbolt=passbolt-iframe-password-share',
    contentScriptFile: [
			// Warning: script and styles need to be modified in
			// chrome/data/passbolt-iframe-password-share.html
    ],
    contentScriptWhen: 'ready',
    onAttach: function (worker) {
      Worker.add('Share', worker, {
        onDestroy: function () {
          TabStorage.remove(worker.tab.id, 'sharedPassword');
          TabStorage.remove(worker.tab.id, 'shareWith');
        }
      });

      app.events.config.listen(worker);
      app.events.editPassword.listen(worker);
      app.events.passboltPage.listen(worker);
      app.events.secret.listen(worker);
      app.events.share.listen(worker);
      app.events.user.listen(worker);
      app.events.template.listen(worker);
    }
  });
};
exports.ShareDialog = ShareDialog;

},{"../app":1,"../model/tabStorage":43,"../model/worker":45,"../sdk/page-mod":62}],60:[function(require,module,exports){
/**
 * Promise Chrome Wrapper
 * Allow using promise in chrome almost like firefox sdk
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

/**
 * A promise is created and return along with the methods to change its state.
 * @returns {{resolve: resolve, reject: reject, promise: *}}
 */
var defer = function () {
  var pReject, pResolve,
    promise = new Promise(function (resolve, reject) {
      pResolve = resolve;
      pReject = reject;
    });

  return {
    resolve: function () {
      pResolve.apply(promise, arguments);
    },
    reject: function () {
      pReject.apply(promise, arguments);
    },
    promise: promise
  }
};
exports.defer = defer;

/**
 * Return the chrome Promise object.
 */
exports.Promise = Promise;
},{}],61:[function(require,module,exports){
/**
 * l10n Chrome Wrapper
 * Allow translating in chrome almost like firefox sdk
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */

/**
 * Get the translation of a given text
 * @param txt {string} The text to translate
 * @return {string}
 */
var get = function(txt) {
  return txt;
};
exports.get = get;

},{}],62:[function(require,module,exports){
/**
 * PageMod Chrome Wrapper
 * Allow using pagemods in chrome almost like firefox sdk
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence GNU Affero General Public License http://www.gnu.org/licenses/agpl-3.0.en.html
 */
var ScriptExecution = require('../sdk/scriptExecution').ScriptExecution;
var Worker = require('../sdk/worker').Worker;
var self = require('../sdk/self');
var Crypto = require('../model/crypto').Crypto;
var Workers = require('../model/worker');

/**
 * PageMod Chrome Wrapper
 *
 * @param args
 * @constructor
 */
var PageMod = function(args) {
  this.args = args;
  this._ports = []; // list of tab ids in which the pagemod has a port open
  this._listeners = []; // list of listeners initialized by this pagemod
  this.__init();
};

/**
 * Members
 * @type {{}}
 */
PageMod.prototype.args = {};

/**
 * Public functions
 * Part of Firefox SDK
 */
/**
 * PageMod Destroy
 */
PageMod.prototype.destroy = function () {
  // Stops the page-mod from making any more modifications.
  // Once destroyed the page-mod can no longer be used.
  // Modifications already made to open documents by content scripts will not be undone
  // Unsuported: stylesheets added by contentStyle or contentStyleFile, will be unregistered immediately.
  if(typeof this._listeners['chrome.tabs.onRemoved'] !== 'undefined') {
    chrome.tabs.onRemoved.removeListener(this._listeners['chrome.tabs.onRemoved']);
    chrome.tabs.onReplaced.removeListener(this._listeners['chrome.tabs.onReplaced']);
    chrome.tabs.onUpdated.removeListener(this._listeners['chrome.tabs.onUpdated']);
  }

  if(typeof this._listeners['chrome.runtime.onConnect'] !== 'undefined') {
    chrome.runtime.onConnect.removeListener(this._listeners['chrome.runtime.onConnect']);
  }
  // clear the tab and listeners
  this._ports = [];
  this._listeners = [];
  this._loading = [];

};

/**
 * Private function
 * Not part of Firefox SDK
 */
/**
 * PageMod Init
 */
PageMod.prototype.__init = function() {

  // The url to use for the pageMod include is not a regex
  if(!(this.args.include instanceof RegExp)) {
		if (this.args.include.startsWith('about:blank')) {
			// For URL patterns like 'about:blank?passbolt=passbolt-iframe*'
			// Contrarily to Firefox we do not inject scripts in the page
			// They are loaded via chrome-extension://[pluginid]/js/iframe.html templates
			// We wait for the page mod to initiate the connection
			this.__onIframeConnectInit();
			return;
		} else if (this.args.include.startsWith(chrome.runtime.getURL(''))) {
			// And similarly for any chrome-extension:// urls
			this.__onContentConnectInit();
			return;
		} else {
			this.args.include = new RegExp(this.args.include);
		}
  }

  // When a tab is updated we try to insert content code if it matches
  // the include and contentScriptWhen pageMod parameters
  var _this = this;
  this._listeners['chrome.tabs.onUpdated'] = function(tabId, changeInfo, tab) {
    _this.__onTabUpdated(tabId, changeInfo, tab);
  };
  chrome.tabs.onUpdated.addListener(this._listeners['chrome.tabs.onUpdated']);

  // Sometimes the page is loaded from the cache and the 'onUpdate' listener is
  // not fired. To make sure we cover that case we listen to 'onReplaced' events
  // fired when a tab is replaced with another tab due to prerendering or instant.
  // see. https://bugs.chromium.org/p/chromium/issues/detail?id=109557
  this._listeners['chrome.tabs.onReplaced'] = function (addedTabId, removedTabId) {
    chrome.tabs.get(addedTabId, function(tab){
      _this.__onTabUpdated(tab.id, {status:'complete'}, tab);
    });
  };
  chrome.tabs.onReplaced.addListener(this._listeners['chrome.tabs.onReplaced']);

  // Using attachto a pagemod can be launched to an already opened tab
  // Useful after an install or a reinstall
  // see. attachTo: ["existing", "top"]
  // Existing = attach to already opened tab (default not)
  // Top = attach to only top document and not iframes (we can't attach to iframe in chrome anyway)
  if(typeof this.args.attachTo !== 'undefined') {
    chrome.tabs.query({}, function(tabs){
      tabs.forEach(function(tab){
        _this.__onAttachExistingTab(tab);
      });
    });
  }

  // When a tab is closed cleanup we cleanup
  this._listeners['chrome.tabs.onRemoved'] = function (tabId) {
    var index = _this._ports.indexOf(tabId);
    _this._ports.splice(index, 1);
  };
  chrome.tabs.onRemoved.addListener(this._listeners['chrome.tabs.onRemoved']);
};

/**
 * Manage runtime.onConnect listeners
 *
 * @private
 */
PageMod.prototype.__initConnectListener = function(portName, tabId, iframe) {
  var _this = this;
  if(typeof iframe === 'undefined') {
    iframe = false;
  }
  this._listeners['chrome.runtime.onConnect'] = function (port) {
    // check if the portname match
    if(port.name === portName) {

      // if there is a connection on the port for a pagemod that
      // was previously matching on that tab but not anymore
      if(!iframe && !_this.__checkUrl(port.sender.tab.url)) {
          // detach any existing worker
          if(Workers.exists(_this.args.name, port.sender.tab.id)) {
            Workers.get(_this.args.name, port.sender.tab.id).destroy('destroying worker because url changed');
          }
          return;
      }

      // add the sender tab id to the list of active tab for that worker
      if(typeof tabId === 'undefined' || tabId === port.sender.tab.id) {
        _this._ports.push(port.sender.tab.id);

        var worker = new Worker(port, iframe);
        _this.args.onAttach(worker);
      }
    }
  };
  chrome.runtime.onConnect.addListener(this._listeners['chrome.runtime.onConnect']);
};

/**
 * iFrame port init
 * @private
 */
PageMod.prototype.__onIframeConnectInit = function() {
  // We use the passbolt part of the location for ifrrame portname
  // e.g. about:blank?passbolt=iframeId
  var iframeId = this.args.include.split('passbolt=')[1];
  iframeId = iframeId.replace('*', '');
  this.portname = iframeId;
  // console.log(this.args.name + ' iframe page mod openening port on ' + this.portname);
  this.__initConnectListener(this.portname, undefined, true);
};

/**
 * Content code port init
 * @private
 */
PageMod.prototype.__onContentConnectInit = function() {
  // We use the content file name as portname
  var portname = this.args.include;
	var replaceStr = chrome.runtime.getURL('/data/');
  portname = portname.replace(replaceStr, '').replace('.html','');
  this.portname = portname;
  // console.log(this.args.name + ' content page mod opening port on ' + this.portname);
  this.__initConnectListener(this.portname);
};

/**
 * When a pagemod is requested on an already opened tab
 *
 * Refresh the page so that it can trigger a proper onTabUpdate
 * so that we have a clean state. Note that we can't just proceed with a onTabUpdate as
 * here might be some scripts already included in the page and we can't remove them
 *
 * @param tab
 * @private
 */
PageMod.prototype.__onAttachExistingTab = function(tab) {
  // We can't insert scripts if the url is not https or http
  // as this is not allowed, instead we insert the scripts manually in the background page if needed
  if (!(tab.url.startsWith('http://') || tab.url.startsWith('https://'))) {
    return;
  }

  // if the url match the pagemod requested pattern
  if (tab.url.match(this.args.include)) {
    chrome.tabs.reload(tab.id);
  }
};

/**
 * When a tab is updated
 *
 * @param tabId
 * @param changeInfo
 * @param tab
 * @private
 */
PageMod.prototype.__onTabUpdated = function(tabId, changeInfo, tab) {
  // Mapping tabs statuses from chrome -> firefox
  // loading = start
  // complete = ready|end // default
  var status = 'complete';
  if(typeof this.args.contentScriptWhen !== 'undefined' && this.args.contentScriptWhen === 'start') {
    status = 'loading';
  }

  // When the tab status is marked as complete
  if(changeInfo.status != status) {
    return;
  }

  // We can't insert scripts if the url is not https or http
  // as this is not allowed, instead we insert the scripts manually in the background page if needed
  if (!(tab.url.startsWith('http://') || tab.url.startsWith('https://'))) {
    return false;
  }

  // Check if pagemod url pattern match tab url
  if (!this.__checkUrl(tab.url)) {
    return;
  }

  // if there is not already a worker in that tab
  // generate a portname based on the tab it and listen to connect event
  // otherwise reuse the already an active worker in that tab to accept incoming connection
  this.portname = 'port-' + Crypto.uuid(tabId.toString());
  if (this._ports.indexOf(tabId) === -1) {
    this.__initConnectListener(this.portname, tabId);
  }

  // a helper to handle insertion of scripts, variables and css in target page
  var scriptExecution = new ScriptExecution(tabId);

  // set portname in content code as global variable to be used by data/js/port.js
  scriptExecution.setGlobals({portname: this.portname});

  // Set JS global variables if needed
  if (typeof this.args.contentScriptOptions !== 'undefined' && Object.keys(this.args.contentScriptOptions).length) {
    scriptExecution.setGlobals(this.args.contentScriptOptions);
  }

  // Inject JS files if needed
	// TODO don't insert if the JS if its already inserted
  var scripts = this.args.contentScriptFile.slice();
  scripts.unshift('data/js/lib/port.js'); // add a firefox sdk-like self.port layer
  scriptExecution.injectScripts(scripts);

  // Inject CSS files if needed
  var styles = this.args.contentStyleFile.slice();
  if (styles.length > 0) {
    // TODO don't insert if the CSS is already inserted
    scriptExecution.injectCss(styles);
  }
};

/**
 * Check if a given URL match the pattern provided in the args
 *
 * @param url
 * @returns {boolean}
 * @private
 */
PageMod.prototype.__checkUrl = function(url) {
  if (!(url.match(this.args.include))) {
    // console.debug('Pagemod' + this.args.name + ' URL:' + tab.url + ' do not match ' + this.args.include);
    return false;
  }
  // console.debug('Pagemod' + this.args.name + ' URL:' + tab.url + ' match ' + this.args.include);
  return true;
};

/**
 *
 * A little Factory to match the firefox syntax
 */
var pageMod = function(args) {
  return new PageMod(args);
};
exports.PageMod = pageMod;

},{"../model/crypto":31,"../model/worker":45,"../sdk/scriptExecution":64,"../sdk/self":65,"../sdk/worker":68}],63:[function(require,module,exports){

/**
 * Port Chrome Wrapper
 *
 * @param port
 * @constructor
 */
var Port = function(port) {
  this._port = port;
};

/**
 * On() call a callback for a given message name
 *
 * @param msgName
 * @param callback
 */
Port.prototype.on = function(msgName, callback) {
  _this = this;
  this._port.onMessage.addListener(function (msg) {
    var args = Object.keys(msg).map(function (key) {return msg[key]});
    args = Array.prototype.slice.call(args, 1);
    if (msg[0] === msgName) {
      callback.apply(_this, args)
    }
  });
};

/**
 * Send a message to the content code
 *
 * @param msgName string
 * @param token uuid
 * @param status SUCCESS | ERROR
 */
Port.prototype.emit = function () {
  this._port.postMessage(Array.prototype.slice.call(arguments));
};
exports.Port = Port;

},{}],64:[function(require,module,exports){
/**
 * ScriptExecution Helper
 * Make it easier to chrome.tabs.executeScript multiple scripts.
 *
 * @copyright (c) 2017 Passbolt SARL
 * @licence ISC https://opensource.org/licenses/ISC
 * @credit https://github.com/ReeganExE/chrome-script-execution
 */
/**
 * ScriptExecution Constructor
 *
 * @param tabId int
 * @constructor
 */
function ScriptExecution(tabId) {
  this.tabId = tabId;
}

/**
 * Array of js file names with path
 *
 * @param fileArray array
 * @returns ScriptExecution object
 */
ScriptExecution.prototype.injectScripts = function (fileArray) {
  var _this = this;
  return Promise.all(fileArray.map(function (file) {
    return exeScript(_this.tabId, file);
  })).then(function () {
    return _this;
  });
};

/**
 * Array of css file names with path
 *
 * @param fileArray array
 * @returns ScriptExecution object
 */
ScriptExecution.prototype.injectCss = function (fileArray) {
  var _this = this;
  return Promise.all(fileArray.map(function (file) {
    return exeCss(_this.tabId, file);
  })).then(function () {
    return _this;
  });
};

/**
 * Insert javascript code in the page
 *
 * @param fileArray array
 * @returns ScriptExecution object
 */
ScriptExecution.prototype.executeScript = function (fileArray) {
  var _this = this;

  fileArray = Array.prototype.slice.call(arguments);
  return Promise.all(fileArray.map(function (code) {
    return exeCodes(_this.tabId, code);
  })).then(function () {
    return _this;
  });
};

/**
 * Set a global variables in the content code environment
 * @param name
 * @param value
 */
ScriptExecution.prototype.setGlobals = function (options) {
  var value, code;
  for (var key in options) {
    value = options[key];
    code = 'var ' + key + '="';
    if (typeof value === 'string') {
      code += options[key];
    } else {
      throw Error('ScriptExecution.setGlobal unsuported type');
    }
    code += '";';
  }
  this.executeScript(code);
};

/**
 * Call an async function of chrome.tabs and makes it a promise
 *
 * @param fn function to execute
 * @param tabId int
 * @param info info object
 * @returns Promise
 */
function promiseTo(fn, tabId, info) {
  return new Promise(function (resolve) {
    fn.call(chrome.tabs, tabId, info, function () {
      return resolve();
    });
  });
}

/**
 * Insert a script file in the page
 *
 * @param tabId
 * @param path
 * @returns Promise
 */
function exeScript(tabId, path) {
  var info = { file: path, runAt: 'document_end' };
  return promiseTo(chrome.tabs.executeScript, tabId, info);
}

/**
 * Insert a stylesheet
 *
 * @param tabId
 * @param path
 * @returns {Promise}
 */
function exeCss(tabId, path) {
  var info = { file: path, runAt: 'document_end' };
  return promiseTo(chrome.tabs.insertCSS, tabId, info);
}

/**
 * Insert a script code snippet in the page
 *
 * @param tabId
 * @param code
 * @returns {Promise}
 */
function exeCodes(tabId, code) {
  var info = { code: code, runAt: 'document_end' };
  return promiseTo(chrome.tabs.executeScript, tabId, info);
}

exports.ScriptExecution = ScriptExecution;

},{}],65:[function(require,module,exports){
/**
 * Self chrome wrapper
 */
var data =  {
   url : function(url) {
    if(typeof url === 'undefined') url = '';
    return 'chrome-extension://' + chrome.runtime.id + '/data/' + url;
  }
};
exports.data = data;

},{}],66:[function(require,module,exports){
/**
 * Port Chrome Wrapper
 *
 * @param port
 * @constructor
 */
var Tab = function(tab) {
  this._tab = tab;
  this.id = tab.id;
  this.url = tab.url;
  this.callbacks = {};

  var _this = this;

  // setup on ready event
  this._onTabUpdated = function (tabId, changeInfo, tab) {
    // if tab is the same than the current worker tab
    // and is fully loaded
    if(_this.id == tabId && changeInfo.status == 'complete') {
      _this.triggerEvent('ready', tab);
    }
  };
  chrome.tabs.onUpdated.addListener(this._onTabUpdated);

  // setup on removed event
  this._onTabRemoved = function (tabId) {
    if(_this.id == tabId) {
      chrome.tabs.onRemoved.removeListener(_this.onTabRemoved);
      _this.triggerEvent('removed', tab);
    }
  };
  chrome.tabs.onRemoved.addListener(this._onTabRemoved);
};

/**
 * Destroy the tab listeners
 * Called when the worker is destroyed
 */
Tab.prototype.destroy = function() {
  chrome.tabs.onUpdated.removeListener(this._onTabUpdated);
  chrome.tabs.onRemoved.removeListener(this._onTabRemoved);
};

/**
 * Add an event listener
 *
 * @param eventName
 * @param callback
 */
Tab.prototype.on = function(eventName, callback) {
  this.callbacks[eventName] = callback;
};

/**
 * Remove an event listener
 *
 * @param eventName
 */
Tab.prototype.removeListener = function(eventName) {
  delete this.callbacks[eventName];
};

/**
 * Trigger an event
 *
 * @param eventName
 */
Tab.prototype.triggerEvent = function (eventName) {
  if (typeof this.callbacks[eventName] !== 'undefined') {
    var args = Array.prototype.slice.call(arguments, 1);
    this.callbacks[eventName].apply(this, args);
  }
};

exports.Tab = Tab;

},{}],67:[function(require,module,exports){
/**
 * Timers chrome wrapper.
 */

exports.setTimeout = setTimeout;
exports.clearTimeout = clearTimeout;
exports.setInterval = setInterval;
exports.clearInterval = clearInterval;

},{}],68:[function(require,module,exports){
var Port = require('../sdk/port').Port;
var Tab = require('../sdk/tab').Tab;

/**
 * PageMod Worker Chrome Wrapper
 *
 * @param port
 * @constructor
 */
var Worker = function(port, iframe) {
  this.port = new Port(port);
  this.tab = new Tab(port.sender.tab);
  this.callbacks = {};
  this.iframe = iframe;

  // make sure the worker self destroy
  // when the tab its running in is closed
  var _this = this;
  this.tab.on('removed', function () {
    _this.destroy('tab was closed');
  });

  // make sure the worker self destroy
  // when it's an iframe worker and the iframe is unloaded
  if(iframe) {
    this.onPortDisconnect = function() {
      _this.port._port.onDisconnect.removeListener(_this.onPortDisconnect);
      _this.destroy('iframe got unloaded');
    };
    _this.port._port.onDisconnect.addListener(_this.onPortDisconnect);
  }
};

/**
 * Add event listener
 * @param eventName
 * @param callback
 */
Worker.prototype.on = function (eventName, callback) {
  this.callbacks[eventName] = callback;
};

/**
 * Trigger an event listener
 * @param eventName
 */
Worker.prototype.triggerEvent = function (eventName) {
  if (typeof this.callbacks[eventName] !== 'undefined') {
    this.callbacks[eventName].apply();
  }
};

/**
 * Destroy the worker
 */
Worker.prototype.destroy = function (reason) {
  // console.debut('Destroying worker because ' + reason);
  // A detach event is fired just before removal.
  this.triggerEvent('detach');

  // remove the content script from the page
  // Not possible...

  // remove all registered listeners
  if(this.iframe) {
    this.port._port.onDisconnect.removeListener(this.onPortDisconnect);
  }
  this.tab.destroy();

  //delete this.callbacks;
  delete this.port;
  delete this.tab;
};

exports.Worker = Worker;

},{"../sdk/port":63,"../sdk/tab":66}]},{},[28]);
